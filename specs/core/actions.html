<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset='utf-8'>
  <meta name="description" content="This document provides a means of advertising actions (RESTful HTTP operations) that can be performed on a Linked Data
    resource.">
  <title>OSLC Actions</title>
  <script src=
              'https://cdn.jsdelivr.net/gh/oasis-tcs/tab-respec@v2.1.14/builds/respec-oasis-common.min.js'
          async="" class='remove'>
  </script>
  <script type="text/javascript">
  var respecConfig = {
    specStatus : "WD",
    revision: "01",

    license : "cc-by-4",

    additionalLicenses : [{
       licenseName : "Apache License 2.0",
       licenseURI : "https://www.apache.org/licenses/LICENSE-2.0",
     }],


    // Only include h1 and h2 level
    maxTocLevel: 2,

    shortName : "actions",
    conformanceLabelPrefix: "Actions",

    // if there a publicly available Editor's Draft, this is the link
    edDraftURI: "https://raw.githack.com/oslc-op/oslc-specs/master/specs/core/actions.html",

    // if this is a LCWD, uncomment and set the end of its review period
    // lcEnd: "2009-08-05",

    // includePermalinks: true,

    chairs : [ {
      name : "Jim Amsden",
      mailto : "jamsden@us.ibm.com",
      company: "IBM",
      companyURL: "http://www.ibm.com/"
    }, {
      name : "Andrii Berezovskyi",
      mailto: "andriib@kth.se",
      company: "KTH",
      companyURL: "https://www.kth.se/en"
    }],
    editors : [ {
            name : "Martin Pain",
            mailto : "martinpain@uk.ibm.com",
            company : "IBM",
            companyURL : "http://ibm.com/"
    },
    {
        name:       "Samuel Padgett",
        mailto:     "spadgett@us.ibm.com",
        company:    "IBM",
        companyURL: "http://ibm.com/"
    } ],

    wg: "OASIS OSLC OP",
    wgShortName:  "oslc-op",
    wgURI: "https://github.com/oslc-op/oslc-specs",

    namespaces : [ {
            href : "http://open-services.net/ns/core#",
            prefix : "oslc"
    } ],

    localBiblio : {
    }
  };
  </script>
</head>

<body>
  <section id='abstract'>
    This document provides a means of advertising actions (RESTful
    HTTP operations) that can be performed on a Linked Data
    resource.
  </section>

  <section id='sotd'>
    <em>Early Working Draft: formating into respec and aligning
    with 3.0 principles</em>
  </section>

  <section id='toc'></section>

  <section id='intro'>
    <h2>Introduction</h2>

    <section id="what-are-actions" class="informative">
    <h3>What are actions?</h3>

    <p>This specification provides a means of advertising actions
    that can be performed on (or in the context of) a specific
    resource. For example, a <a href=
    "http://open-services.net/wiki/change-management/State-Transitions-for-Change-Requests/#CM-Actions-with-the-Core-Workgroup-Actions-Proposal">
    change request can have a "resolve" action or other state
    transitions</a>. Providers implementing this specification
    allow consumers to list and select actions that can be executed
    on a given resource <em>R</em> without needing to understand
    <em>R</em>'s type, properties, lifecycle, etc. See <a href=
    "#what-do-consumers-need-to-know">What do consumers need to
    know?</a>. Each action provides a few primary pieces of
    information: "what does this action do?", "how do I execute
    this action?", and "how do I determine if the action succeeded
    or failed?". These are described in the <a href=
    "#implConform">normative specification sections</a> below.</p>

    <p>[[Image:Actions-Overview-Questions.png]]</p>

    <p>Those questions are answered by action bindings. The action
    can have multiple bindings in order to provide compatibility
    with more than one type of consumer, or to support multiple
    interaction patterns (for example, programmatic execution in
    addition to execution via a delegated UI dialog). Each of the
    different bindings provided by a single action must be
    <em>semantically equivalent</em> - that is, they must each
    achieve the same thing, just in a different way and possibly at
    a different point in time - although they may not be
    <em>semantically identical</em>, because of differing side
    effects or details.</p>

    <p>The scenarios that this specification enables are listed on
    the [[Actions 2.0 Scenarios]] page.</p>
    </section>

    <section id="high-level-interaction-model" class="informative">
    <h3>High level interaction model</h3>

    <ul>
      <li>Providers annotate resources with actions.</li>

      <li>Consumers discover available actions on existing
      resources.

        <ul>
          <li>Domain-specific or profile-specific clients (the
          normal case) do so as described in and/or constrained by
          the appropriate specification(s) and/or profile(s) (for
          example, a profile provided by a domain specification);
          they need to understand whatever interaction pattern(s)
          the profile includes in order to successfully invoke
          actions that comply with it.</li>

          <li>Generic (cross-domain) clients might rely only on the
          entirety of Core Actions (this specification), and be
          able to display and/or invoke actions from many resource
          types and interaction patterns.</li>
        </ul>
      </li>
    </ul>
    </section>

    <section id="what-do-consumers-need-to-know" class="informative">
    <h3>What do consumers need to know?</h3>

    <p>By using this explicit, loosely-coupled description of
    actions that are available on a given resource R, consumers
    <em>do not</em> need to understand:</p>

    <ul>
      <li>the <code>rdf:type</code> of R, or the domain that
      defines it</li>

      <li>the native lifecycle of R</li>

      <li>the properties of R unrelated to Actions, or the meaning
      of their values</li>
    </ul>

    <p>instead, the consumer only needs to know:</p>

    <ul>
      <li>the URI of R</li>

      <li>how to find the actions and their bindings that exist on
      R (as defined by this specification)</li>

      <li>how to execute those bindings (as defined by this
      specification)</li>

      <li>how to determine the success/failure of its request to
      execute the action (as defined by this specification)</li>
    </ul>

    <p>Therefore this specification frees the execution of these
    actions from domain specifics, instead providing a common point
    of interoperability between multiple domain specifications.</p>
    </section>

    <section id="domain-specific-consumers" class="informative">
    <h3>Domain-specific consumers</h3>

    <p>The first-order concern of domain specifications is
    <em>consumers written to that specification</em>. Domain
    specifications provide one or more specification profiles for
    the consumers to support. Those profile(s) define the minimum
    subset of this specification that the consumer must implement.
    The consumer itself is not aware of specification profiles at
    run time -- it is a design-time decision about what interaction
    patterns to implement with what (if any) restrictions, and how
    to document those design-time decisions.</p>

    <p>The process that a consumer supporting a given profile
    (whether or not that profile was provided by a domain
    specification) would follow to find resources with actions it
    is capable of consuming is:</p>

    <ul>
      <li>Decide what the set of interesting resources is. It might
      be one or many, depending upon the usage scenario.</li>

      <li>For each interesting resource:

        <ul>
          <li>Find <a href="#oslc-action-discovery">available
          actions</a> by looking for the <code>oslc:action</code>
          predicate on the resource
          </li>

          <li>For each such action

            <ul>
              <li>Find the bindings for that action by looking for
              the <code>oslc:binding</code> predicate on the
              action.</li>

              <li>For each action binding:

                <ul>
                  <li>For each interaction pattern that is
                  supported by the consumer (which must include, at
                  a minimum, the interaction patterns required by
                  the chosen profile):

                    <ul>
                      <li>Determine if this consumer is compatible
                      with that binding, by determining whether the
                      binding uses that interaction pattern and
                      whether it adheres to any restrictions on the
                      bindings that this consumer can execute (e.g.
                      any restrictions specified against that
                      interaction pattern in the profile that the
                      consumer was implemented against).</li>
                    </ul>
                  </li>
                </ul>
              </li>

              <li>Note: At least one interaction pattern must match
              on a binding for the consumer to be compatible with
              that binding. It is theoretically possible that
              multiple interaction patterns may match one binding
              if interaction patterns that extend those in 2.0 are
              defined in certain ways, but in the 2.0 specification
              at most one interaction pattern matches any single
              binding.</li>
            </ul>
          </li>

          <li>If at least one of the bindings is compatible with
          this consumer, then the action is compatible with this
          consumer.</li>
        </ul>
      </li>

      <li>Do whatever the client is coded to do.</li>
    </ul>

    <p>The process such a client would follow to <em>execute</em>
    any action it is capable of consuming is usually to form and
    make an HTTP request, but some interaction patterns dictate a
    different process. The instructions for forming and making the
    request are found by following <code>oslc:binding</code>
    link(s) and examining the object resources.</p>

    <ul>
      <li>Given the action to execute and the binding(s) for that
      action that the consumer is compatible with (found using the
      process above)</li>

      <li>If more than one binding is compatible with the consumer,
      choose one using whatever criteria the consumer prefers. e.g.
      it can have an order of preference (decided at implementation
      time) based on the interaction patterns' cost of execution
      (e.g. time, resources), or the desired interaction with the
      user (e.g. dialogs, or ability to execute at a later
      time).</li>

      <li>Follow the instructions of the selected interaction
      pattern to execute the action via the chosen binding. For
      example, if the binding is an <code>http:Request</code>
      resource, form the HTTP request from it.</li>
    </ul>

    <p>Note: no mention is made of how many HTTP requests are
    required to retrieve the Actions/bindings/etc. data mentioned,
    since that is implementation-dependent. <a href=
    "#best-practices">Best practices</a> suggest minimizing them,
    especially when UI presentation performance is important.</p>
    </section>

    <section id="providers" class="informative">
    <h3>Providers</h3>

    <p>The second-order concern of domain specifications is
    <em>providers written to that specification</em>. The process
    such a provider would follow to <em>expose</em> resources with
    actions its domain-specific clients are capable of consuming
    is:</p>

    <ul>
      <li>Decide what the set of interesting resources is.

        <ul>
          <li>The most likely case is resources owned/exposed by
          the provider itself.</li>
        </ul>
      </li>

      <li>For each interesting resource:

        <ul>
          <li>Find any existing actions that the provider can add a
          new binding for

            <ul>
              <li>The action that the binding is for must be
              <em>semantically equivalent</em> to the provider's
              action to be exposed, where equivalence is defined by
              the provider of the action. (There is no
              loosely-coupled means of determining semantic
              equivalence between providers, other than when two
              bindings are already on the same
              <code>oslc:Action</code>. So usually new bindings can
              only be added to existing actions by the same
              provider that created the bindings already on the
              action, or some implementation-specific means would
              have to exist for the two providers to agree that the
              two bindings are semantically equivalent).</li>
            </ul>
          </li>

          <li>Add the provider's action to be exposed, either as a
          new <code>oslc:binding</code> link or as a new
          <code>oslc:action</code> link.</li>
        </ul>
      </li>
    </ul>
    </section>

    <section id="generic-or-cross-domain-consumers" class="informative">
    <h3>Generic or cross-domain consumers</h3>

    <p>Domain specifications often care little about consumers
    <em>not</em> written to that particular specification, beyond
    adhering to basic HTTP and Linked Data principles. Core
    specifications, in effect, enable cross-domain consumers.</p>

    <p>The process such a consumer would follow to <em>find</em>
    resources with actions it is capable of consuming, and
    <em>executing</em> those, is the same as for a domain-specific
    consumer, but where the interaction patterns supported by the
    consumer are as wide a set as the implementation allows, rather
    than being based on a specification profile. A generic consumer
    could, for example, look at all actions
    (<code>oslc:action</code> predicates) across a set of
    resources, present those to a user, and let the user select one
    or more to invoke. The only restriction on the set of
    interaction patterns is the set of those understood by the
    consumer code, since there is no single domain specification or
    profile involved.</p>
    </section>

    <section id="templates" class="informative">
    <h3>Templates</h3>

    <p>One particular usage pattern for Actions is their use as
    <em>templates</em>, especially by schedulers. An analogy is a
    partially filled-out form, for example a drug prescription,
    that one copies and submits (renews) multiple times. It is not
    always easy, given one of those forms, to distinguish between
    the original and the copies; they have nearly identical
    content, but they are used very differently. The original is
    used to manufacture new copies, and each copy is "traded" for a
    set quantity and type of medicine.<br></p>

    <p>The same pattern occurs with schedulers: during a
    "configuration" phase, a form is filled out (for future use)
    and saved; later in time, during one or more "execution" or
    "use" phases, a copy of the saved form is submitted in order to
    cause a result such as executing an Action. The resource acting
    as the saved form and the copies made from it have very similar
    representations, but distinct identifiers (URIs). The copying
    process is usually accomplished by submitting a representation
    (of the resource acting as the template) to a creation factory,
    which responds to successful requests with a newly minted URI
    (identifying the new copy). Creation factories implemented via
    HTTP POST have considerable discretion in how they use the
    input representation, and in some cases (like <a href=
    "http://open-services.net/wiki/automation">OSLC Automation</a>) the act of creation may
    carry with it side effects, like execution of an Automation
    Request. There is nothing specific to OSLC Automation in the
    template usage pattern, however; indeed, readers might well
    recognize a similar pattern in saved queries and favorite lists
    on many Web sites. Hence, the <a href="#interaction-patterns">interaction patterns</a> described
    later can generally each be used as part of a template pattern
    at a higher level of abstraction.</p>
    </section>
  </section>

  <section id="terms">
    <h2>Terminology</h2>

    <dl>
      <dt>Action</dt>

      <dd>
        Linked Data-based hypertext describing an end -- the
        desired semantics -- and some means to accomplish that end
        via HTTP-based interaction pattern(s) that may or may not
        also involve user interaction. Although the term's use in
        this specification is primarily to actions available when
        the response is formed, that limit does not come from this
        definition. Action resources can be used to describe other
        varieties, like past, future, or potential actions;
        enabling this additional flexibility in the definition is
        intentional, and it has been exploited already by at least
        the <a href=
        "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/">
        Automation domain</a>.
      </dd>

      <dt>Action binding</dt>

      <dd>A means of executing an action, or instructions for
      executing an action. Each action may have multiple action
      bindings to allow the action to support multiple interaction
      patterns. Each action binding uses an interaction pattern and
      specifies values (e.g. URL and request body contents) that
      the consumer must apply to that interaction pattern to
      execute that particular action.</dd>

      <dt>Interaction pattern</dt>

      <dd>An abstract definition of how a consumer and provider
      interact in order to execute an action. The definition
      includes a rule consumers use to recognize that an action
      binding uses the interaction pattern, instructions for
      sending messages, and instructions that consumers use to
      determine the results. For a simple interaction pattern using
      a single-request HTTP flow, determining the result can be as
      simple as inspecting the HTTP status code.</dd>

      <dt>
        <a href="#specification-profiles">Specification profiles</a>
      </dt>

      <dd>
        A named, coherent subset of a specification, often used in
        a specific domain, like <a href=
        "http://open-services.net/wiki/change-management">Change Management</a> or <a href=
        "http://open-services.net/wiki/automation">Automation</a>. An actions
        <em>specification profile</em> includes one or more
        <em>interaction patterns</em> for which each
        <em>Action</em> resource governed by that <em>profile</em>
        must provide an <em>Action binding</em>. The additional
        constraints simplify the range of code clients are required
        to implement, making it cheaper and easier to adopt. This
        is a specification-only concept, not a runtime concept.
      </dd>

      <dt>Provider</dt>

      <dd>For the purposes of the specification, an OSLC Actions
      provider is any OSLC implementation that serves resources of
      type oslc:Action or that serves action bindings, irrespective
      or whether it links to them from its owns resources or from
      resources hosted by other OSLC implementations.</dd>

      <dt>Consumer</dt>

      <dd>For the purposes of this specification, an OSLC Actions
      consumer is any OSLC implementation that can use resources of
      type oslc:Action to execute that action using its <em>action
      bindings</em>.</dd>
    </dl>
  </section>

  <section id="intended-audience" class='informative'>
    <h2>Intended audience</h2>

    <p>This section is non-normative; it provides a guide as to
    which sections of the specification it is important for
    different audiences to understand and comply with.</p>

    <ul>
      <li><strong>Implementors of OSLC consumers</strong> - To
      reduce implementation effort, implementations may choose to
      be compliant with only a subset of this specification. To
      support interoperability between implementations that do so
      it is recommended that consumers pick one or more
      <em><a href="#specification-profiles">specification
      profiles</a></em> and support, as a minimum, the subset of
      this specification included in those profiles.</li>

      <li><strong>Implementors of OSLC providers</strong> - To
      reduce implementation effort, implementations may choose to
      be compliant with only a subset of this specification. To
      support interoperability between implementations that do so
      it is recommended that providers pick one or more
      <em><a href="#specification-profiles">specification
      profiles</a></em> and ensure that every action that they
      provide has at least one <em>Action binding</em> that falls
      within the constraints of each <em>profile</em>.</li>

      <li><strong>Authors of specifications that re-use Action
      resources</strong> - It is recommended that domain
      specifications reusing Action resources select a <em><a href=
      "#specification-profiles">specification profile</a></em> that
      implementations of the domain specification should support as
      a minimum. Such specifications can refer to a profile that is
      defined or referenced in this specification, or may define
      their own. Such specifications may also want to define
      additional interaction patterns, but are advised to reuse or
      extend the ones defined in this specification if possible, to
      aid interoperability.</li>
    </ul>
  </section>

  <section class='informative'>
    <h2>Motivation</h2>

    <div class='note'>
      TODO: fill in motivation
    </div>
  </section>

  <section id='concepts' class='informative'>
    <h2>Basic Concepts</h2>

    <div class='note'>
      TODO: fill in basic concepts (tease out of intro)
    </div>
  </section>

  <section id='implConform'>
    <h2>Implementation Conformance</h2>

    <section id="re-use-by-domain-specs">
    <h3>Re-use by domain specifications</h3>

    <p>Domain specifications re-using this specification
    SHOULD make their readers aware of <a href=
    "#best-practices">Best Practices</a> for representing actions
    and their related resources.<br></p>

    <p>Domain specifications re-using this specification are
    strongly <strong>RECOMMENDED</strong> to require at least one
    specification profile for interoperability within the target
    domain. They SHOULD re-use the profiles
    defined or referenced in this specification where possible, or
    they MAY define new specification profile(s)
    when no existing profile meets their needs. The working groups
    defining them must consult with OSLC Core before defining new
    profiles, to determine if they are better added to Core or kept
    separate.</p>

    <p>Domain specifications re-using this specification
    MAY add new constraints beyond the ones here.
    Domain specifications re-using this specification <strong>MUST
    NOT</strong> weaken absolute constraints (MUST, MUST NOT) in
    this specification.</p>

    <p>Domain specifications re-using this specification
    MAY define new predicates beyond the ones here
    that link to actions not available when the response is formed.
    Likewise they MAY define new <a href=
    "#types-of-actions">action types</a>, as <a href=
    "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/">OSLC
    Automation 2.1</a> does for <a href=
    "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#Teardown-action-type">
    teardown actions</a>; widely applicable action types
    SHOULD be allocated (by the Core working
    group) within the OSLC Core vocabulary.</p>

    <p>Domain specifications re-using this specification
    MUST comply with requirements imposed by later
    sections in this specification, for example those in <a href=
    "#recognizing-patterns">recognizing interaction patterns</a>
    and <a href="#profiles-other">specification profiles</a>. The
    preceding list of examples might be incomplete; domain
    specification authors are responsible for finding and
    understanding all requirements levied on them in other
    sections.</p>
    </section>

    <section id="oslc-action-discovery">
    <h3>Discovering the actions available from a resource</h3>

    <p>Any resource MAY link to any number of
    Actions, using the <code>oslc:action</code> predicate as shown
    in the graphic below. The <code>oslc:action</code> predicate
    links to actions <em>available when the response is
    formed</em>. (In a distributed system, clients can lose race
    conditions that result in an action that appears as "available"
    having its execution requests rejected. However, it is not
    expected that actions will change frequently.)</p>
    </section>

    <section id="action-resources">
    <h3>Action resources</h3>

    <p>All resources in this specification, such as Actions, action
    bindings, and HTTP requests, MAY be
    represented as either blank nodes or URI-identified resources,
    and when identified by URIs either hash or non-hash URIs
    MAY be used.</p>

    <p>[[Image:Actions-Finding-Actions-From-Resources.png]]</p>
    </section>

    <section id="types-of-actions">
    <h3>Types of actions</h3>

    <p>Action resources identify what type of actions they are, so
    that consumers can know how to choose an action (for
    programmatic selection) or how to display an action (for
    selection by a user). For loose integration, some general
    action types are defined in this specification, and types
    applicable to individual domains are defined in specifications
    for those domains (for example, <a href=
    "http://open-services.net/wiki/change-management">OSLC Change Management</a> and
    <a href="http://open-services.net/wiki/automation">OSLC Automation</a>). This
    specification lists some known action sub-types in <a href=
    "#action-subtypes">Resources: Action subtypes</a>.</p>

    <p>Action types are identified by <code>rdf:type</code> values,
    e.g. <code>oslc-automation:TeardownAction</code>, which
    SHOULD all be <code>rdfs:subClassOf</code>
    <code>oslc:Action</code>. Since informal OSLC Core guidance
    states that providers cannot depend upon client-side
    inferencing, action representations are multi-typed: they
    MUST contain <code>oslc:Action</code> as one
    type, and MAY (usually do, in practice)
    contain additional types that convey more specific semantics
    necessary for programmatic consumption. The additional type
    URIs MAY belong to any vocabulary or
    namespace, however working groups in need of new types should
    consult with Core before defining new actions outside the Core
    namespace. Widely applicable action types should be allocated
    (by the Core working group) within the OSLC Core
    vocabulary.</p>
    <pre>
<code>&lt; http://example.com/sa/2314?stopREST &gt; a oslc:Action, oslc-automation:TeardownAction ;     # This

&lt; http://example.com/sa/2314?stopREST &gt; a              oslc-automation:TeardownAction ;     # NOT this
</code>
</pre>

    <p>Action types should be at a level of abstraction suitable
    for human and/or programmatic consumption.</p>

    <p>Implementations <strong>MUST NOT</strong> assume that
    actions with the same action types are semantically
    <em>identical</em>. Actions SHOULD use a
    combination of both standardised and (if needed)
    non-standardised types to make the identification of its type
    more specific. The standardised types allow loosely-coupled
    integration, and the more specific non-standard types allow
    comparison between actions and value-add for consumers that do
    know about the non-standard terms at implementation time.
    (However, as stated earlier in this paragraph, implementations
    cannot assume that actions with exactly the same set of
    <code>rdf:type</code> values are identical - they are only as
    equivalent as those types define.)</p>

    <blockquote>
      <p>As a hypothetical example, two actions could both identify
      themselves as <code>ns:DeletionAction</code>, but one could
      delete a child resource of the current context, and one could
      delete the context itself. It is more useful to (some)
      consumers if the actions identify themselves as being of-type
      <code>[oslc:Action, ns:DeletionAction,
      x:DeleteDelegateResource]</code> and <code>[oslc:Action,
      ns:DeletionAction, x:DeleteCurrentResourceAction]</code>,
      respectively. This is so that the standardised types allow
      loosely-coupled integration, and the specific non-standard
      types allow comparison between actions and value-add for
      consumers that do know about the non-standard terms at
      implementation time.</p>
    </blockquote>
    </section>

    <section id="executing-actions">
    <h3>Action bindings: instructions for executing available actions</h3>

    <p>Each <a href="#oslc-action-discovery">available action</a>
    contains one or more <code>oslc:binding</code> predicates, each
    of which links to a resource containing instructions for
    executing the action, such as the <a href=
    "http://www.w3.org/TR/HTTP-in-RDF10/#RequestClass">HTTP request
    resource</a> (<code>http:Request</code>) shown below; the
    <a href="#Resource-Action">resource shape</a> allows zero
    bindings in other cases.<br></p>

    <p>A consumer executes an action by following a single
    interaction pattern, applying information supplied in the
    action binding to the pattern. Out of the patterns that it
    supports, the consumer MUST use a pattern
    whose recognition rule is matched by the binding. If multiple
    patterns match (theoretically possible, but not currently
    specified), the consumer MAY use any
    interaction pattern whose recognition rule is matched by the
    action binding. This specification permits the use of resources
    with types in addition to those defined in interaction patterns
    in this specification, but it assigns them no meaning and when
    they are used interoperability will be reduced. Consumers
    MUST tolerate other resource types, but
    MAY ignore them.</p>

    <p>[[Image:Actions-Request-Linkage.png]]</p>

    <p>Each binding describes a means that the consumer can use to
    execute the action, by matching one or more interaction
    patterns and supplying data needed to perform it. Each of the
    bindings linked to from a single Action MUST
    be semantically equivalent -- the different bindings are
    different means of achieving the same desired result, within
    the bounds of what the Action's type(s) require and prohibit.
    However, the different bindings MAY (and
    almost always will) source any parameters from different
    sources (e.g. some use a dialog), MAY have
    different numbers of parameters, MAY be used
    to execute the action at different times (e.g. some can be used
    to schedule it for execution at a later time), and
    MAY have different side effects unless its
    types' semantics specifically prohibit them.</p>

    <p>The consumer picks a binding based on which interaction
    pattern(s) the consumer understands and which one it wants to
    use. The consumer then executes the action in the manner
    defined by the interaction pattern.</p>
    </section>

    <section id="future-actions">
    <h3>Future actions</h3>

    <p>This specification defines a predicate for discovering
    actions that are not available when the response is formed but
    that might become available at some point in the future,
    possibly on a related resource. See <a href=
    "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/">OSLC
    Automation 2.1</a>'s associated scenarios for example uses
    specific to the Automation domain, and the paragraph below on
    resource shapes for another. Domain specifications
    SHOULD re-use <code>oslc:futureAction</code>
    rather than inventing their own new term, when the semantics
    are compatible. This specification also defines a
    <code>oslc:executes</code> predicate for linking from a
    currently available action to a corresponding future action;
    this was also motivated by Automation 2.1's scenarios.</p>

    <blockquote>
        <p>Non-normative note: feedback on draft specifications
        indicated more general scenarios exist outside the
        Automation domain, that could be satisfied by re-using
        existing Core capabilities if Core Actions was explicit on
        how to do so.</p>
    </blockquote>

    <p>Resource shapes can be used as a general way to expose the
    set of actions that a resource is capable of supporting but
    cannot be executed at the point in time when action discovery
    is occurring. Existing resources can link to a shape, for
    example via <code>oslc:instanceShape</code>. Creation factories
    can link to a shape describing the resources they are capable
    of manufacturing, via a <code>oslc:resourceShape</code> link
    from a <a href="http://open-services.net/bin/view/Main/OslcCoreSpecification">creation
    factory</a>. In each case, if the shape has one or more
    <code>oslc:futureAction</code> properties, then clients will
    expect that future action resources describe actions that the
    client might find linked to instances that the shape applies
    to, via the <code>oslc:action</code> predicate. That is, if a
    shape <code>S</code> applies to a resource <code>R</code>, and
    the shape <code>S</code> has a <code>oslc:futureAction</code>
    link to action <code>A</code>, then a client would expect that
    at some point during the existence of <code>R</code> that
    <code>R</code> would have an <code>oslc:action</code> link to
    an action <code>B</code> whose type list matches the type list
    of <code>A</code>. Similarly, <code>B</code> can link back to
    <code>A</code> when scenarios require this; for example, when
    it becomes necessary for a user to choose amongst future
    actions whose programmatic descriptions are very similar and
    schedule execution for a later time.</p>

    <blockquote>
        <p>Non-normative concrete example: if work order has a
        shape with a future action link to a "add log entry"
        action, then clients will expect that the work order is
        likely to have an <code>oslc:action</code> link to at least
        one "add log entry" action; if a work order creation
        factory <code>C</code> has a resource shape with a future
        action link to a "add log entry" action, then clients will
        expect that all work orders it creates are likely to have
        an <code>oslc:action</code> link to at least one "add log
        entry" action. Those "add log entry" actions might not be
        available all the time, or to every user, or on every work
        order the factory creates, and clients have to tolerate
        that; future actions are hints, not guarantees.</p>
    </blockquote>

    <p>This specification does not require that future actions have
    any bindings, that any bindings they do have are complete, or
    what the relationship is between any bindings present on a
    future action and those present when it becomes available for
    execution. Domain specifications re-using this specification
    MAY add such requirements.</p>
    </section>

    <section id="recognizing-patterns">
    <h3>Recognizing the interaction patterns used by each binding</h3>

    <p>Each interaction pattern defines how consumers should
    recognize it.</p>

    <p>Each action binding can match more than one interaction
    pattern, in which case the consumer can choose which one to
    use.</p>

    <p>When defining new interaction patterns in other
    specifications, the new patterns SHOULD
    either:</p>

    <ul>
      <li>extend an existing interaction pattern, but add in
      additional recognition conditions that use predicates under
      the control of the extending specification (to avoid
      incorrectly matching existing action bindings that do not
      follow the newly defined extension interaction pattern).

        <ul>
          <li>These extension interaction patterns
          MUST be 100% compatible with the
          patterns they extend -- that is, when Action bindings use
          these extension patterns the providers
          MUST support those bindings being
          executed as either the base or extension pattern.</li>

          <li>New interaction patterns that extend existing
          patterns MUST include an explicit
          reference to the extended pattern's recognition rule in
          the new pattern's recognition rule.</li>

          <li>They MAY also include a copy of the
          extended pattern's rule alongside that reference for
          clarity.</li>
        </ul>
      </li>
    </ul>

    <p>or:</p>

    <ul>
      <li>define a completely new interaction pattern that is
      recognized by (at least) an <code>rdf:type</code> value that
      is under the control of the extending specification.</li>
    </ul>
    </section>

    <section id="interaction-patterns">
    <h3>Interaction patterns</h3>

    <p>Consumers invoke actions to achieve a certain desired
    result, by choosing a specific binding and interaction pattern
    to construct one or more messages. A single action can have
    multiple bindings, and a single binding can potentially be used
    with multiple interaction patterns. Some interaction patterns
    always consist of a single message, but others permit or
    require multiple messages to achieve the same desired result.
    This distinction becomes critical when a consumer is trying to
    determine whether or not its <strong>desired result</strong>
    has been achieved, based on message responses - that is, what
    the <strong>final status</strong> of the action's execution
    is.<br></p>

    <p>When using interaction patterns that always consist of a
    single HTTP message flow, consumers expect the HTTP status code
    to <strong>equate</strong> to the success or failure of the
    desired result (the final status of executing the action): if a
    success status code (2xx class) is returned, consumers
    interpret that to mean that the action ran
    <strong>successfully</strong>. Single-message interaction
    pattern definitions SHOULD avoid other
    interpretations.<br></p>

    <p class="conformance">When using interaction patterns that sometimes or always
    consist of multiple HTTP message flows, in general consumers
    cannot expect "the" HTTP status code to <strong>equate</strong>
    to the success or failure of the desired result (the final
    status of executing the action), because the issue of which
    message's status code to use arises. Multi-message interaction
    patterns MUST define how a consumer
    unambiguously determines the final status of its desired result
    from the messages.</p>

    <p>Similar considerations apply to non-HTTP interaction
    patterns, although none are defined in Actions 2.0.</p>

    <blockquote>
      <p>Non-normative note: One consequence of this is that
      multi-message interaction patterns cannot inherit from
      single-message patterns, because of the contradiction that
      arises in a consumer's interpretation of the result of its
      messages. In the presence of certain <strong>implementation
      assumptions</strong> it is sometimes possible to "mix" them,
      but this has been found to be complex and error-prone.</p>

      <p>Non-normative note: A single binding can potentially be
      used with multiple interaction patterns if a new IP is
      created whose recognition rule adds a required property to an
      existing IP. There are no known existent cases of this in
      practice as of this specification being finalized.</p>
    </blockquote>

    <p>Each interaction pattern specifies:</p>

    <ul>
      <li>A <strong>pattern recognition rule</strong> - the
      restrictions that bindings must adhere to in order for
      consumers to recognize that pattern as one a binding
      uses.</li>

      <li>Instructions for <strong>execution</strong> of a binding
      using that interaction pattern.</li>

      <li>Instructions for <strong>finding the final
      status</strong> of executing a binding using that interaction
      pattern.</li>

      <li>Optionally, <strong>additional provider
      constraints</strong> that must be adhered to when using that
      pattern.</li>
    </ul>

    <blockquote>
      <p>Non-normative note: specifying <code>oslc:usage</code> =
      <code>oslc:default</code> on at least one of an action's
      bindings can help consumers decide between bindings. This is
      useful whenever multiple bindings exist on the action and
      several bindings satisfy the recognition rule for the same
      interaction pattern. If the provider marks one as a default,
      consumers have a clearer choice.</p>
    </blockquote>

    <section id="patterns-final-status">
    <h4>Final execution status</h4>

    <p>The Actions vocabulary defines a predicate
    <code>oslc:finalStatusLocation</code> whose RDF object conveys
    instructions telling a consumer how to determine the actual
    result of using the interaction pattern.</p>

    <p>This specification defines the following values for the
    <code>oslc:finalStatusLocation</code> predicate, and their
    meanings when they are used. Other specifications may define
    additional values. Exactly one value must be present; if a
    provider implementation happens to work in such a way that
    multiple values would always give the same result and it wishes
    to cater to both sets of consumers, it needs to create one
    binding for each value as described in the note below.</p>

    <ul>
      <li><code>http:StatusCode</code> is used when the HTTP 1.1
      status code conveys the actual result. This includes the
      status code class processing defined in HTTP, that is that
      any 2xx status code means success, and so on. Only
      single-message interaction patterns can use this value.</li>

      <li><code>oslc:Dialog</code> is used when the OSLC Core
      delegated dialog protocol determines how to determine the
      actual result, which uses a combination of the HTTP status
      code and the <code>oslc:results</code> output object.</li>

      <li>
        <code>oslc:ActionDialog</code> is used when the <a href=
        "#action-dialog-results">action dialog</a> protocol
        determines how to determine the actual result, which uses a
        combination of the HTTP status code and the
        <code>oslc:results</code> output object.
      </li>

      <li>
        <code>oslc-automation:AutomationResult</code> is used when
        an Automation Result's <a href=
        "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0/#State-and-Verdict-properties">
        state and verdict properties</a> convey the actual result.
        This is typically used for cases where providers expect an
        action's implementation to be long-running, and therefore
        to require an <a href=
        "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0/#Asynchronous-and-Synchronous-Automation-Execution">
        asynchronous style</a> using multiple messages.
      </li>
    </ul>

    <p>Other values can be used, but some consumers will not
    understand them.</p>

    <blockquote>
      <p>Non-normative note: The final status location is defined
      in the binding's RDF (and is included in the pattern's
      recognition rule) - not just implied by which pattern is used
      - so that in future other interaction patterns can be defined
      that are identical to existing interaction patterns, except
      in the location of the final status. For example, if a
      provider always performs <a href=
      "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0/#Asynchronous-and-Synchronous-Automation-Execution">
      synchronous execution of the Automation Request</a> and sets
      the response's status code to match the <a href=
      "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0/#State-and-Verdict-properties">
      Automation Result's verdict</a>, and it wants to make its
      actions executable both by consumers that only understand
      OSLC Automation requests and by consumers that only
      understand standard HTTP requests, such a provider could
      create two bindings that differ only in the object of the
      <code>oslc:finalStatusLocation</code> triple. Core Actions
      provides no facility to avoid repeating the rest of the
      binding information, although standard RDF facilities can be
      used.</p>
    </blockquote>
    </section>

    <section id="pattern-empty-body">
    <h4>Pattern: HTTP request with empty body</h4>

    <p>This interaction pattern consists of the consumer making an
    HTTP request with a zero-length body to a URL specified by the
    provider to execute the action.</p>

    <ul>
      <li>
        <strong>Interaction pattern</strong> (See <a href=
        "#interaction-patterns">Interaction patterns</a>)
      </li>

      <li><strong>Identifier:</strong>
      "pattern-http-empty-body"</li>

      <li><strong>Name:</strong> HTTP request with empty body</li>

      <li>
        <strong>Contained in profile:</strong> <a href=
        "#profile_POST_resource_shape">POST RDF described by a OSLC
        Resource Shape to the Action resource
        ("profile-action-shape-post")</a>
      </li>
    </ul>

    <section id="pattern-recognition-rule">
    <h5>Pattern recognition rule</h5>

    <p>For any action binding that uses this interaction
    pattern:</p>

    <ul>
      <li>at least one <code>rdf:type</code> property
      MUST have the value
      <code>http:Request</code>, and</li>

      <li>the <code>http:body</code> property MUST
      have the value <code>rdf:nil</code>.</li>

      <li>the <code>oslc:finalStatusLocation</code> property
      MUST have the value
      <code>http:StatusCode</code>.</li>
    </ul>

    <p>A binding is deemed to use this pattern if it meets these
    restrictions.</p>

    <p>[[Image:Actions-Pattern-Empty-Body.png]]</p>

    <p>See <a href=
    "http://open-services.net/wiki/core/Actions-2.0-Examples/#example-empty-body">the
    Examples appendix</a> for a full RDF example.</p>
    </section>

    <section id="execution">
    <h5>Execution</h5>

    <p>To execute an action using this interaction pattern, a
    consumer uses the binding's properties to send a request as
    described in <a href="#constructing-http-requests"></a>, but
    with a Content-Length header with a value of zero, and an empty
    request body.</p>
    </section>
    </section>

    <section id="pattern-resource-shape">
    <h4>Pattern: HTTP request with Resource Shape to describe the request body</h4>

    <p>This interaction pattern allows an Action to describe the
    request body that it accepts in terms of an OSLC resource
    shape.</p>

    <ul>
      <li>
        <strong>Interaction pattern</strong> (See <a href=
        "#interaction-patterns">Interaction patterns</a>)
      </li>

      <li><strong>Identifier:</strong>
      "pattern-http-resource-shape"</li>

      <li><strong>Name:</strong> HTTP request with Resource Shape
      to describe the request body</li>

      <li>
        <strong>Contained in profile:</strong> <a href=
        "#profile_POST_resource_shape">POST RDF described by a OSLC
        Resource Shape to the Action resource
        ("profile-action-shape-post")</a>
      </li>
    </ul>

    <section id="pattern-recognition-rule_1">
    <h5>Pattern recognition rule</h5>

    <p>For any action binding that uses this interaction
    pattern:</p>

    <ul>
      <li>at least one <code>rdf:type</code> property
      MUST have the value of
      <code>http:Request</code>, and</li>

      <li>the <code>http:body</code> property MUST
      link to a resource with at least one <code>rdf:type</code> of
      <code>oslc:ResourceShape</code>.</li>

      <li>the <code>oslc:finalStatusLocation</code> property
      MUST have the value
      <code>http:StatusCode</code>.</li>
    </ul>

    <p>A binding is deemed to use this pattern if it meets these
    restrictions.</p>

    <p>[[Image:Actions-Pattern-Resource-Shape.png]]</p>

    <p>See <a href=
    "http://open-services.net/wiki/core/Actions-2.0-Examples/#example-resource-shape">the
    Examples appendix</a> for a full RDF example.</p>
    </section>

    <section id="execution_1">
    <h5>Execution</h5>

    <p>To execute an action using this interaction pattern, a
    consumer uses the binding's properties to send a request as
    described in <a href="#constructing-http-requests"></a>. The
    consumer constructs the HTTP body by finding or constructing an
    RDF resource that matches the defined resource shape and using
    an appropriate serialisation of that resource as the HTTP
    request body.</p>
    </section>
    </section>

    <section id="pattern-body-repn">
    <h4>Pattern: HTTP request with fixed body</h4>

    <p>This interaction pattern allows an action binding to provide
    a resource that is to be serialized as the request body.</p>

    <ul>
      <li>
        <strong>Interaction pattern</strong> (See <a href=
        "#interaction-patterns">Interaction patterns</a>)
      </li>

      <li><strong>Identifier:</strong>
      "pattern-http-fixed-body"</li>

      <li><strong>Name:</strong> HTTP request with fixed body</li>

      <li><strong>Contained in profiles:</strong>
      <em>(None)</em></li>
    </ul>

    <section id="pattern-recognition-rule_2">
    <h5>Pattern recognition rule</h5>

    <p>For any action binding that uses this interaction
    pattern:</p>

    <ul>
      <li>at least one <code>rdf:type</code> property
      MUST have the value
      <code>http:Request</code>, and</li>

      <li>the <code>http:body</code> property MUST
      link to a resource that meets these conditions:

        <ul>
          <li>at least one <code>rdf:type</code> property
          MUST have the value
          <code>oslc-automation:ParameterInstance</code>, and</li>

          <li>MUST have exactly one
          <code>rdf:value</code> property that links to the
          resource that is to be serialised</li>
        </ul>
      </li>

      <li>the <code>oslc:finalStatusLocation</code> property
      MUST have the value
      <code>http:StatusCode</code>.</li>
    </ul>

    <p>A binding is deemed to use this pattern if it meets these
    restrictions.</p>

    <p>[[Image:Actions-Pattern-Fixed-Body.png]]</p>

    <p>See <a href=
    "http://open-services.net/wiki/core/Actions-2.0-Examples/#example-body-repn">the
    Examples appendix</a> for a full RDF example.</p>
    </section>

    <section id="execution_2">
    <h5>Execution</h5>

    <p>To execute an action using this interaction pattern, a
    consumer uses the binding's properties to send a request as
    described in <a href="#constructing-http-requests"></a>. The
    consumer constructs the HTTP body by serializing the resource
    that is the object of the <code>rdf:value property</code> of
    the <code>oslc-automation:ParameterInstance</code> resource,
    and the consumer uses the HTTP <code>Content-Type</code> header
    to specify the media type used on the request to execute the
    action.</p>

    <blockquote>
      <p>Non-normative note: The consumer will have to choose a
      media type that is appropriate. Appropriate media types could
      be detected from the <code>http:headers</code> property on
      the <code>http:Request</code> resource if present, or from
      the <code>Content-Type</code> used on previous responses the
      consumer has received from the provider (for example, when
      retrieving the <code>rdf:value</code>'s representation), or
      (when the binding specifies a POST request) from an
      <code>Accept-Post</code> response header from the resource
      linked to by the <code>http:requestURI</code> property.</p>
    </blockquote>
    </section>
    </section>

    <section id="pattern-autoreq">
    <h4>Pattern: Automation request</h4>

    <p>This interaction pattern allows an Action to be executed by
    creating an Automation Request.</p>

    <ul>
      <li>
        <strong>Interaction pattern</strong> (See <a href=
        "#interaction-patterns">Interaction patterns</a>)
      </li>

      <li><strong>Identifier:</strong>
      "pattern-automation-request"</li>

      <li><strong>Name:</strong> Automation request</li>

      <li>
        <strong>Contained in profile:</strong> <a href=
        "#profile_automation_request">Create an Automation Request
        ("profile-automation-request")</a>
      </li>
    </ul>

    <section id="pattern-recognition-rule_3">
    <h5>Pattern recognition rule</h5>

    <p>For any action binding that uses this interaction
    pattern:</p>

    <ul>
      <li>at least one <code>rdf:type</code> property
      MUST have the value
      <code>http:Request</code>, and</li>

      <li>the <code>http:body</code> property MUST
      link to a resource that meets these conditions:

        <ul>
          <li>at least one <code>rdf:type</code> property
          MUST have the value
          <code>oslc-automation:AutomationRequest</code>.</li>
        </ul>
      </li>

      <li>the <code>oslc:finalStatusLocation</code> property
      MUST have the value
      <code>oslc-automation:AutomationResult</code>.</li>
    </ul>

    <p>A binding is deemed to use this pattern if it meets these
    restrictions.</p>

    <blockquote>
      <p>Non-normative note: the <code>rdf:type</code> property
      requirement implies that only RDF representations are
      compatible with this pattern, as would be expected from its
      dependence on RDF resources defined in OSLC
      Automation.<br></p>
    </blockquote>

    <p>[[Image:Actions-Pattern-Automation-Request.png]]</p>

    <p>See <a href=
    "http://open-services.net/wiki/core/Actions-2.0-Examples/#example-autoreq">the Examples
    appendix</a> for a full RDF example.</p>
    </section>

    <section id="additional-provider-constraints">
    <h5>Additional provider constraints</h5>

    <p>In addition, action bindings using this interaction
    pattern:</p>

    <ul>
      <li>MUST specify POST as the value of the
      <code>http:mthd</code> property in the action binding's
      <code>http:Request</code> resource</li>

      <li>
        MUST specify an
        <code>oslc-automation:AutomationRequest</code> that
        conforms to the requirements placed on those resources by
        the <a href=
        "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0">
        OSLC Automation specification</a>.
      </li>

      <li>MUST include an
      <code>oslc-automation:executesAutomationPlan</code> property
      on the Automation Request, pointing to the Automation Plan
      that this action binding executes.</li>

      <li>are <strong>RECOMMENDED</strong> to use the
      <code>http:requestURI</code> property of the action binding's
      <code>http:Request</code> resource to link to a standard
      creation factory (described by a
      <code>oslc:CreationFactory</code> resource) that accepts
      Automation Requests for the appropriate service provider, so
      clients can obtain the creation factory's URI from the
      <code>oslc:creation</code> property.</li>

      <li>MUST accept any valid Automation
      Requests for the Automation Plan executed by this action
      binding (i.e. it must not rely on the consumer submitting
      exactly the Automation Request that was provided by the
      Action), <em>if and only if</em> a GET on the
      <code>http:requestURI</code> returns a resource with an
      <code>rdf:type</code> of
      <code>oslc:CreationFactory</code>.</li>
    </ul>
    </section>

    <section id="execution_3">
    <h5>Execution</h5>

    <p>When executing an action binding according to this
    interaction pattern, a consumer follows the execution
    instructions of the <a href="#pattern-body-repn">HTTP request
    with fixed body</a> interaction pattern, with the exception
    that the consumer constructs the HTTP body content from the
    Automation Request. The consumer may construct this body
    content by merely serialising the Automation Request that has
    been provided, or they may alter that Automation Request to
    provide additional or different parameter values if they
    understand the parameters that the linked Automation Plan
    takes, or they may find another way to construct an Automation
    Request for that Automation Plan (e.g. by using a stored
    Automation Request created earlier, or by finding a <a href=
    "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#Template-Dialog-interaction-pattern">
    deferred-execution creation dialog</a> to create the Automation
    Request).</p>

    <p>The client's desired result is to successfully complete
    execution of the action; creating the Automation Request is
    merely the first step. The status of this desired result is
    determined using the corresponding Automation Result's <a href=
    "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#State-and-Verdict-properties">
    state and verdict properties</a>, as would be the case with any
    other Automation Request, not by using the HTTP status codes.
    <a href=
    "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#Asynchronous-and-Synchronous-Automation-Execution">
    Automation permits both</a> single-message and multiple-message
    interactions, but the client MUST use the
    state and verdict for determining the <a href=
    "http://open-services.net/wiki/core/Exposing-arbitrary-actions-on-RDF-resources/#Interaction-patterns">
    status of the client's desired result</a> when the HTTP status
    codes indicate that the creation was successful.</p>
    </section>
    </section>

    <section id="pattern-immed-dialog">
    <h4>Pattern: Delegated UI dialog for immediate execution</h4>

    <p>This interaction pattern consists of the consumer displaying
    a delegated UI dialog to a user for them to perform the action
    immediately, and waiting for the action to be completed or
    cancelled before returning to the consumer.</p>

    <ul>
      <li>
        <strong>Interaction pattern</strong> (See <a href=
        "#interaction-patterns">Interaction patterns</a>)
      </li>

      <li><strong>Identifier:</strong> "pattern-action-dialog"</li>

      <li><strong>Name:</strong> Delegated UI dialog for immediate
      execution</li>

      <li><strong>Contained in profiles:</strong>
      <em>(None)</em></li>
    </ul>

    <section id="pattern-recognition-rule_4">
    <h5>Pattern recognition rule</h5>

    <p>For any action binding that uses this interaction
    pattern:</p>

    <ul>
      <li>at least one <code>rdf:type</code> property
      MUST have the value
      <code>oslc:Dialog</code>, and</li>

      <li>at least one <code>oslc:usage</code> property
      MUST have the value
      <code>oslc:ActionDialog</code>.</li>

      <li>the <code>oslc:finalStatusLocation</code> property
      MUST have the value
      <code>oslc:ActionDialog</code>.</li>
    </ul>

    <p>A binding is deemed to use this pattern if it meets these
    restrictions.</p>

    <p>[[Image:Actions-Pattern-Action-Dialog.png]]</p>

    <p>See <a href=
    "http://open-services.net/wiki/core/Actions-2.0-Examples/#example-immed-dialog">the
    Examples appendix</a> for a full RDF example.</p>
    </section>

    <section id="action-dialog-results">
    <h5>Execution</h5>

    <p>To execute an action binding using this interaction pattern,
    a consumer follows the instructions in the <a href=
    "http://open-services.net/bin/view/Main/OslcCoreSpecification#Delegated_User_Interface_Dialogs">
    OSLC Core Delegated UI specification</a> to display the dialog.
    The dialog is responsible for everything necessary to execute
    the action, including but not limited to accepting any
    parameters and displaying any output, and
    SHOULD be displayed until the action is
    completed or cancelled. The dialog MUST return
    a <code>oslc:results</code> object conforming to the <a href=
    "#resource-results">resource shape for action dialog
    results</a>.</p>

    <p>If the HTTP status code indicates success, the consumer
    determines whether or not the action succeeded using the output
    <code>oslc:results</code> object's verdict property. (This is
    different than selection dialogs and creation dialogs, which
    return a URI to a domain- or implementation-specific resource -
    action dialogs only have to return a verdict whose URI
    identifies the final status of the action's execution).</p>

    <ul>
      <li><code>oslc-automation:passed</code> means that the action
      was executed successfully</li>

      <li><code>oslc-automation:failed</code> means that the action
      was attempted but failed</li>

      <li><code>oslc-automation:canceled</code> means that the
      dialog was cancelled, whether or not the action was
      attempted</li>
    </ul>

    <blockquote>
      <p>Non-normative note: This interaction pattern is intended
      to be used where the actions will complete very quickly,
      otherwise the user is stuck with the delegated UI dialog on
      the screen waiting for the action to complete.</p>

      <p>Non-normative note: The dialog displays and gives the user
      the option to start the action, and should be displayed until
      the action is completed or cancelled. It may give the option
      to cancel before the action has started and/or while the
      action is running. <code>oslc-automation:canceled</code> is
      used for either of those cases.</p>
    </blockquote>
    </section>
    </section>

    <section id="pattern-dialog-delayed-execution">
    <h4>Pattern: Delegated UI dialog for later execution</h4>

    <p>This pattern is defined by the OSLC Automation
    specification: <a href=
    "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#Template-Dialog-interaction-pattern">
    Deferred execution dialog interaction pattern</a>.</p>

    <ul>
      <li>
        <strong>Interaction pattern</strong> (See <a href=
        "#interaction-patterns">Interaction patterns</a>)
      </li>

      <li><strong>Identifier:</strong>
      "pattern-delegated-execution-dialog"</li>

      <li><strong>Name:</strong> Delegated UI dialog for later
      execution</li>

      <li><strong>Contained in profiles:</strong>
      <em>(None)</em></li>
    </ul>
    </section>

    <section id="pattern-creation-factory">
    <h4>Pattern: Automation Creation Factory</h4>

    <p>This pattern is defined by the OSLC Automation
    specification: <a href=
    "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#pattern-autoreq-creation-factory">
    Creation Factory interaction pattern</a>.</p>

    <ul>
      <li>
        <strong>Interaction pattern</strong> (See <a href=
        "#interaction-patterns">Interaction patterns</a>)
      </li>

      <li><strong>Identifier:</strong>
      "pattern-automation-creation-factory"</li>

      <li><strong>Name:</strong> Automation Creation Factory</li>

      <li><strong>Contained in profiles:</strong>
      <em>(None)</em></li>
    </ul>
    </section>
  </section>
  </section>

  <section id='resources'>
    <h2>Resources</h2>

    <p>This section defines the resources of the Actions
    specification.</p>

    <section id="actions-namespace">
    <h3>Actions Namespace</h3>

    <p>The namespace used for resources and properties <em>defined
    in this specification</em> is as follows:</p>

    <ul>
      <li>Namespace URI:
      <code>http://open-services.net/ns/core#</code></li>

      <li>Default Prefix: <code>oslc</code></li>
    </ul>
    </section>

    <section id="other-namespaces">
    <h3>Other namespaces</h3>

    <p>This specification re-uses content from namespaces defined
    by other specifications. This specification assumes the
    following mappings from prefixes to namespaces, in addition to
    those suggested in <a href=
    "http://open-services.net/bin/view/Main/OSLCCoreSpecAppendixA">OSLC
    Core</a>.</p>

    <table>
      <thead>
        <tr>
          <th><em>Prefix</em></th>

          <th><em>Namespace</em></th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><code>http</code></td>

          <td>
            <a href=
            "http://www.w3.org/2011/http#">http://www.w3.org/2011/http#</a>
          </td>
        </tr>

        <tr>
          <td><code>http-methods</code></td>

          <td>
            <a href=
            "http://www.w3.org/2011/http-methods#">http://www.w3.org/2011/http-methods#</a>
          </td>
        </tr>

        <tr>
          <td><code>oslc-automation</code></td>

          <td>
            <a href=
            "http://open-services.net/ns/auto#">http://open-services.net/ns/auto#</a>
          </td>
        </tr>
      </tbody>
    </table>
    </section>

    <section id="Resource-Action">
    <h3>Resource: Action</h3>

    <ul>
      <li><strong>Name:</strong> <code>Action</code></li>

      <li><strong>Description:</strong> An Action provides a
      representation of an action, process or operation that can be
      executed against the subject resource, for example start or
      stop.</li>

      <li>
        <strong>Type URI:</strong> <a href=
        "http://open-services.net/ns/core#Action"><code>http://open-services.net/ns/core#Action</code></a>
      </li>
    </ul>

    <section id="action-properties">
    <h4>Action Properties</h4>

    <table>
      <thead>
        <tr>
          <th><em>Prefixed Name</em></th>

          <th><em>Occurs</em></th>

          <th><em>Read-only</em></th>

          <th><em>Value-type</em></th>

          <th><em>Representation</em></th>

          <th><em>Range</em></th>

          <th><em>Description</em></th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><em>OSLC Core:</em> Common Properties</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://purl.org/dc/terms/title">dcterms:title</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral">
            XMLLiteral</a>
          </td>

          <td>N/A</td>

          <td>N/A</td>

          <td>Title (reference: Dublin Core) of the resource,
          represented as rich text using XHTML content.
          SHOULD include only content that is
          valid and suitable inside an XHTML &lt;div&gt;
          element.</td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://purl.org/dc/terms/description">dcterms:description</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Zero-or-one">Zero-or-one</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral">
            XMLLiteral</a>
          </td>

          <td>N/A</td>

          <td>N/A</td>

          <td>Descriptive text (reference: Dublin Core) about the
          resource, represented as rich text using XHTML content.
          SHOULD include only content that is
          valid and suitable inside an XHTML &lt;div&gt;
          element.</td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://www.w3.org/1999/02/22-rdf-syntax-ns#type">rdf:type</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#One-or-many">One-or-many</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Resource">Resource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Reference">Reference</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>The resource type URIs. At least one type
          MUST be <code>oslc:Action</code>.</td>
        </tr>

        <tr>
          <td><em>OSLC Core Actions:</em> Start of additional
          properties</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://open-services.net/ns/core#binding">oslc:binding</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Zero-or-many">Zero-or-many</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#AnyResource">AnyResource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Either">Either</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>Instructions for executing the action. It is likely
          that the target resource will be an
          <code>http:Request</code>,
          <code>oslc-automation:AutomationRequest</code>, or
          <code>oslc:Dialog</code>, but that is not necessarily the
          case. Multiple occurrences of this property
          MUST be different ways of achieving the
          same operation; they are semantically the same, but
          achieved through different data or technologies or at
          different times.</td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://open-services.net/ns/core#executes">oslc:executes</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Zero-or-one">Zero-or-one</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#AnyResource">AnyResource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Either">Either</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>
            Link to the future action, if any, that a currently
            available action realizes. It is likely that the target
            resource will be an <code>oslc:Action</code>, but that
            is not necessarily the case. See <a href=
            "#future-actions">future actions</a> for example uses.
          </td>
        </tr>
      </tbody>
    </table>
    </section>

    <section id="action-subtypes">
    <h4>Action subtypes</h4>

    <p>The following is an informal, and potentially incomplete,
    registry of action subtypes:</p>

    <ul>
      <li><code>oslc-automation:TeardownAction</code> - tears down
      an already-deployed resource</li>
    </ul>

    <p>Before defining new subtypes, please <a href=
    "#types-of-actions">coordinate with the community</a>.</p>
    </section>
    </section>

    <section id="property-oslc-action">
    <h3>Common Property: oslc:action</h3>

    <p>In addition to resource definitions, this specification
    defines one property below that can occur in any RDF resource.
    This property is defined to be a well-known way of finding
    available actions on any resource. Resource types may want to
    specify their own property/ies instead, but this one is defined
    as a sensible default.</p>

    <p><font color="red">Automation WG proposes that this property
    be moved to Core's <a href=
    "http://open-services.net/bin/view/Main/OSLCCoreSpecAppendixA">"common
    properties" appendix</a> during the finalization
    phase.</font></p>

    <table>
      <thead>
        <tr>
          <th><em>Prefixed Name</em></th>

          <th><em>Occurs</em></th>

          <th><em>Read-only</em></th>

          <th><em>Value-type</em></th>

          <th><em>Representation</em></th>

          <th><em>Range</em></th>

          <th><em>Description</em></th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><em>OSLC Core:</em> Common Properties</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://open-services.net/ns/core#action">oslc:action</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Zero-or-many">Zero-or-many</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#AnyResource">AnyResource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Either">Either</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>
            An action that the provider asserts is available for
            execution by clients <em>at the time the representation
            was formed</em>. In a distributed system, clients can
            lose race conditions that result in an
            "available"-appearing action's execution requests being
            rejected. It is likely that the target resource will be
            an <code>oslc:Action</code>, but that is not
            necessarily the case; <a href=
            "http://open-services.net/wiki/core/Exposing-arbitrary-actions-on-RDF-resources/#executing-actions">
            when it is an <code>oslc:Action</code>, it will have at
            least one binding</a> since this predicate's definition
            requires that the action be available when the response
            is formed.
          </td>
        </tr>
      </tbody>
    </table>
    </section>

    <section id="resource-request">
    <h3>Resource: Request</h3>

    <p>Note: this resource is <strong>re-used</strong> by this
    specification, not defined by it. This specification defines
    the resource shape (how the <a href=
    "http://www.w3.org/TR/HTTP-in-RDF10/#RequestClass">existing W3C
    vocabulary</a> is re-used and extended).</p>

    <ul>
      <li><strong>Name:</strong> <code>Request</code></li>

      <li><strong>Description:</strong> A Request provides a
      representation of an HTTP request. (Reference: HTTP in
      RDF)</li>

      <li>
        <strong>Type URI:</strong> <a href=
        "http://www.w3.org/2011/http#Request"><code>http://www.w3.org/2011/http#Request</code></a>
      </li>
    </ul>

    <section id="request-properties">
    <h4>Request Properties</h4>

    <table>
      <thead>
        <tr>
          <th><em>Prefixed Name</em></th>

          <th><em>Occurs</em></th>

          <th><em>Read-only</em></th>

          <th><em>Value-type</em></th>

          <th><em>Representation</em></th>

          <th><em>Range</em></th>

          <th><em>Description</em></th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><em>OSLC Core:</em> Common Properties</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://www.w3.org/1999/02/22-rdf-syntax-ns#type">rdf:type</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#One-or-many">One-or-many</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Resource">Resource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Reference">Reference</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>The resource type URIs. At least one type
          MUST be <code>http:Request</code>.</td>
        </tr>

        <tr>
          <td><em>HTTP in RDF:</em> Common properties</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://www.w3.org/2011/http#requestURI">http:requestURI</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Resource">Resource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Reference">Reference</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>HTTP Request-URI for the request. (Reference: HTTP
          1.1)</td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://www.w3.org/2011/http#mthd">http:mthd</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Resource">Resource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Reference">Reference</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>
            HTTP method for the request. The target resource
            SHOULD come from the <a href=
            "http://www.w3.org/2011/http-methods">http-methods</a>
            vocabulary. Many clients are likely to support only
            widely used methods such as <a href=
            "http://www.w3.org/2011/http-methods">POST</a>.
          </td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://www.w3.org/2011/http#httpVersion">http:httpVersion</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
          </td>

          <td>Unspecified</td>

          <td>String</td>

          <td>N/A</td>

          <td>N/A</td>

          <td>HTTP protocol version for the request. Providers
          would be wise to support HTTP 1.1 (value: "1.1") in order
          to achieve interoperability in practice.</td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://www.w3.org/2011/http#body">http:body</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#AnyResource">AnyResource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Either">Either</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>Parameters executing the action. It is likely that
          the target resource will be a
          <code>oslc:ResourceShape</code>,
          <code>oslc-automation:ParameterInstance</code>, or an
          <code>oslc-automation:AutomationRequest</code> but that
          is not necessarily the case.</td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://open-services.net/ns/core#usage">oslc:usage</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Zero-or-many">Zero-or-many</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Resource">Resource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Reference">Reference</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>Expected usage pattern for the resource. A value of
          <code>oslc:default</code> can also be used when multiple
          bindings are present on a single action to hints to
          clients which is preferred.</td>
        </tr>

        <tr>
          <td><em>OSLC Core Actions:</em> Start of additional
          properties</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://open-services.net/ns/core#finalStatusLocation">oslc:finalStatusLocation</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Resource">Resource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Reference">Reference</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>How a consumer determines the status of its desired
          result (whether or not it has been achieved), which
          possibly requires multiple message exchanges. It is
          likely that the value will be one of these URIs:
          <code>oslc:Dialog</code>, <code>oslc:ActionDialog</code>,
          <code>http:StatusCode</code>, or an
          <code>oslc-automation:AutomationResult</code>, but that
          is not necessarily the case.</td>
        </tr>
      </tbody>
    </table>

    <p>The <a href="http://www.w3.org/TR/HTTP-in-RDF10/">HTTP
    Vocabulary in RDF 1.0 W3C Working Draft</a> defines additional
    content for describing HTTP requests, beyond those listed
    above; only a subset of HTTP in RDF is used by Core Actions to
    address known scenarios. Implementations that need additional
    content SHOULD re-use the W3C vocabulary where
    possible instead of inventing their own, for example if
    specific headers are required, but client interoperability may
    be limited.</p>

    <blockquote>
      <blockquote>
        <p>Non-normative note: We have talked to the W3C members
        involved in writing this vocabulary about extending
        http:requestURI to allow to be a RDF link instead of a
        string literal whose (string) value happens to be a URI.
        Currently no new work is being done on the vocabulary, but
        there were no objections to the usage.</p>
      </blockquote>
    </blockquote>
    </section>
    </section>

    <section id="resource-results">
    <h3>Resource: results</h3>

    <p>This resource is returned by the <a href=
    "#pattern-immed-dialog">delegated UI dialog for immediate
    execution</a> to indicate the status ("verdict") of the
    execution of the action.</p>

    <p>Note: this resource is <strong>re-used</strong> by this
    specification, not defined by it. This specification defines
    the resource shape (how the <a href=
    "http://open-services.net/ns/core#results">existing type</a> is
    re-used and extended).</p>

    <ul>
      <li><strong>Name:</strong> <code>results</code></li>

      <li><strong>Description:</strong> The results from a
      delegated user interface (UI) dialog.</li>

      <li>
        <strong>Type URI:</strong> <a href=
        "http://open-services.net/ns/core#results"><code>http://open-services.net/ns/core#results</code></a>
      </li>
    </ul>

    <table>
      <thead>
        <tr>
          <th><strong>Prefixed Name</strong></th>

          <th><strong>Occurs</strong></th>

          <th><strong>Read-only</strong></th>

          <th><strong>Value-type</strong></th>

          <th><strong>Representation</strong></th>

          <th><strong>Range</strong></th>

          <th><strong>Description</strong></th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>OSLC Core Actions Properties</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://open-services.net/ns/auto#verdict"><code>oslc-automation:verdict</code></a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#One-or-many">One-or-many</a>
          </td>

          <td>true</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Resource">Resource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Reference">Reference</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>
            URI of the verdict. Providers need to expose at least
            one standard URI for interoperability, but they can
            expose other more specific ones if needed as long as
            all URIs on a single result are semantically
            compatible. It is likely that the target resource will
            be one of the following, but that is not necessarily
            the case: <a href=
            "http://open-services.net/ns/auto#failed"><code>oslc-automation:failed</code></a>,
            <a href=
            "http://open-services.net/ns/auto#passed"><code>oslc-automation:passed</code></a>,
            <a href=
            "http://open-services.net/ns/auto#canceled"><code>oslc-automation:canceled</code></a>
          </td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://open-services.net/ns/core#label"><code>oslc:label</code></a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
          </td>

          <td>true</td>

          <td>
            <a href=
            "http://www.w3.org/2001/XMLSchema#string">String</a>
          </td>

          <td>N/A</td>

          <td>N/A</td>

          <td>
            Short label describing the result (verdict) of the
            action dialog, for example from an <a href=
            "#pattern-immed-dialog">immediate execution action
            dialog</a>.
          </td>
        </tr>
      </tbody>
    </table>
    </section>

    <section id="Resource_ParameterInstance">
    <h3>Resource: ParameterInstance</h3>

    <p>Note: this resource is <strong>re-used</strong> by this
    specification, not defined by it. This specification defines
    the resource shape (how the <a href=
    "http://open-services.net/ns/auto#ParameterInstance">existing
    type</a> is re-used and extended).</p>

    <ul>
      <li><strong>Name:</strong>
      <code>ParameterInstance</code></li>

      <li><strong>Description:</strong> A resource representing a
      HTTP entity-body instance.</li>

      <li><strong>Type URI</strong>
      <code>http://open-services.net/ns/auto#ParameterInstance</code></li>
    </ul>

    <section id="parameterinstance-properties">
    <h4>ParameterInstance Properties</h4>

    <table>
      <thead>
        <tr>
          <th><em>Prefixed Name</em></th>

          <th><em>Occurs</em></th>

          <th><em>Read-only</em></th>

          <th><em>Value-type</em></th>

          <th><em>Representation</em></th>

          <th><em>Range</em></th>

          <th><em>Description</em></th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><em>OSLC Core:</em> Common Properties</td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>

          <td></td>
        </tr>

        <tr>
          <td>
            <a href=
            "http://www.w3.org/1999/02/22-rdf-syntax-ns#type">rdf:type</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#One-or-many">One-or-many</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Resource">Resource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Reference">Reference</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>The resource type URIs. At least one type
          MUST be
          <code>oslc-automation:ParameterInstance</code>.</td>
        </tr>

        <tr>
          <td><code>rdf:value</code></td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
          </td>

          <td>Unspecified</td>

          <td>
            <a href=
            "http://open-services.net/ns/core#AnyResource">AnyResource</a>
          </td>

          <td>
            <a href=
            "http://open-services.net/ns/core#Either">Either</a>
          </td>

          <td>
            <a href="http://open-services.net/ns/core#Any">Any</a>
          </td>

          <td>The value of the parameter, either a resource or a
          typed literal. Untyped literals can be used in place of
          string-typed literals.</td>
        </tr>
      </tbody>
    </table>
  </section>
  </section>
  </section>

  <section id="best-practices">
    <h2>Best Practices</h2>

    <section id="minimize-the-number-of-http-round-trips" class="informative">
    <h3>Minimize the number of HTTP round-trips</h3>

    <p>Actions will often be and/or link to inline resources,
    possibly anonymous ones (without their own URL, i.e. blank
    nodes). But they can be separate, addressable resources if
    needed. Since a client might need to retrieve Action
    descriptions, e.g. in a UI, in order to find the one with the
    correct type (if it is looking for a particular type of
    action), it is likely advantageous to minimize the number of
    HTTP round trips by returning the representation of all a
    resource's actions along with the resource's representation.
    The same pattern applies to <code>oslc:binding</code> object
    resources.</p>
    </section>
    </section>

    <section id="specification-profiles">
    <h2>Specification profiles</h2>

    <section id="specification-profiles-overview">
    <h3>Specification profiles overview</h3>

    <p>An <em>specification profile</em> is a coherent subset of
    this specification. A <em>specification profile</em> includes
    one or more <em>interaction patterns</em> for which each
    <em>Action</em> governed by that <em>profile</em> must provide
    an <em>Action binding</em>. The additional constraints simplify
    the range of code clients are required to implement, making it
    cheaper and easier to adopt. This is a specification-only
    concept, not a runtime concept.</p>

    <p>This specification is very general, broad and extensible. As
    such, writing consumer implementations that support the entire
    specification might require more effort than would be required
    to solve the narrower problem(s) of a specific domain's
    scenarios. To reduce the minimum amount of effort required, we
    define a number of <em>specification profiles</em> (hereafter,
    "profiles"), which specify subsets of the specification as a
    minimum base for interoperability between implementations of
    this specification.</p>

    <p>To be clear, the intention of profiles is to reduce the
    amount of the specification that consumers need to implement to
    be interoperable with providers. Therefore, it is intended that
    the profiles restrict the providers (by requiring them to
    provide, as a minimum, action bindings that conform to certain
    restrictions) so that consumers can include more assumptions
    about what they will find.</p>

    <p>Profiles are chosen at the time that an provider/consumer is
    implemented. They inform what subset of this specification is
    implemented. They are not a runtime concern. Interaction
    patterns are what clients match action bindings against at
    runtime; a provider's design-time choice of supported
    specification profiles determines which interaction patterns
    the implementation supports, and hence which clients it can
    successfully integrate with.</p>

    <section id="using-specification-profiles">
    <h3>Using specification profiles</h3>

    <p>Provider implementations SHOULD choose one
    or more profiles that they will comply with. To "comply with" a
    profile a provider MUST, for each Action
    resource served by that provider, provide <em>at least one</em>
    Action binding that meets the constraints of that profile - as
    well as meeting any other requirements imposed on a provider by
    that profile.</p>

    <p>Consumer implementations SHOULD choose one
    or more profiles to support. To "support" a profile a consumer
    MUST be able to recognize and execute all the
    interaction patterns included in the profile, and meet any
    other requirements imposed on a consumer by that profile.
    Consumers will work best when integrated with providers that
    comply with at least one of the profiles that they support.</p>
    </section>

    <section id="recognizing-profiles">
    <h3>Recognizing profiles</h3>

    <p>Providers SHOULD state, in their user or
    integration documentation, which profile(s) they comply with.
    This information SHOULD include the names of
    the profiles with hyperlinks or URL references to the
    specifications in which they were defined. (If only a subset of
    a provider's actions comply with a profile, the documentation
    SHOULD make it clear which subset that
    is).</p>

    <section id="why-are-profiles-only-identified-in-documentation-not-data"
            class="informative">
    <h4>Why are profiles only identified in documentation, not data?</h4>

    <p>Matching profiles is intended to be an implementation-time
    and integration configuration problem. When a user is deciding
    if two different components are compatible with each other,
    they will look at the documentation and see that a consumer
    supports a given set of profiles of the OSLC Actions
    specification. They will then look at the providers that they
    are considering using and see which profiles of this
    specification that they comply with. They should only expect
    the integrations to be successful where there is a match of at
    least one profile between the consumer and provider involved.
    The identifiers provided for the profiles are intended to allow
    the profiles to be referred to unambiguously in product
    documentation.</p>

    <p>It is possible that implementations that do not share a
    common profile may still work together, at least for some of
    their actions. For example, a provider may have some actions
    that have very simple Action bindings and some that have more
    complex ones. The simpler Action bindings may, on inspection,
    be seen to adhere to the restrictions of a given profile, even
    if that was not the intention of the provider. A consumer that
    supports that profile would then be able to execute the actions
    with the simpler Action bindings, even though the provider had
    not targeted itself at that profile. For this reason the
    profiles are not identified in the data, but instead
    implementations have to look at the Actions available and see
    if they comply with the interaction patterns and other
    restrictions that they support.</p>

    <p>In other words, <strong>compatibility between a consumer and
    a given Action binding is based on the interaction pattern
    being used and any subset or restriction of that pattern that
    the consumer is compatible with</strong>. Profiles merely guide
    consumers as to which interaction patterns (or restrictions
    thereof) they should implement, and to encourage providers to
    produce Action bindings that do not require complex
    consumers.</p>
    </section>
    </section>

    <section id="choosing-one-or-more-profiles-to-implement">
    <h3>Choosing one or more profiles to implement</h3>

    <p>When implementing a consumer or a provider, profile(s)
    SHOULD be chosen by considering the providers
    or consumers (respectively) that the implementation is to
    integrate with. This can be done by looking at specific
    implementations that already exist, or by using the profile
    identified by a domain specification that the implementations
    share, or by considering the likely capabilities of the
    implementations to be integrated.</p>

    <p>Most implementations of this specification will occur in the
    context of another specification, for a specific domain. In
    those cases, implementations SHOULD choose, as
    a minimum, the profile(s) required by that domain
    specification.</p>
    </section>

    <section id="profiles-other">
    <h3>Other specifications</h3>

    <p>Other specifications re-using Action resources are reminded
    that they have <a href="#re-use-by-domain-specs">obligations
    documented in other sections</a>.</p>
    </section>

    <section id="terminology_1">
    <h3>Terminology</h3>

    <ul>
      <li>
        <strong>specification profile</strong> (also "profile") -
        See <a href="#using-specification-profiles"></a>
      </li>

      <li>
        <strong>Comply with</strong> - See <a href=
        "#using-specification-profiles">using specification
        profiles</a>
      </li>

      <li>
        <strong>Support</strong> - See <a href=
        "#using-specification-profiles">using specification
        profiles</a>
      </li>

      <li>
      <strong>Constraints</strong>/<strong>requirements</strong> -
      An <em>specification profile</em> imposes constraints on
      Action bindings, and restrictions on providers and consumers.
      These are defined in the profile's definition.</li>
    </ul>
    </section>

    <section id="specification-profile-definitions">
    <h3>Specification profile definitions</h3>

    <section id="profile_POST_resource_shape">
    <h4>Profile: POST RDF described by a OSLC Resource Shape to the Action
        resource</h4>

    <ul>
      <li>
        <strong>Specification profile</strong> (See <a href=
        "#specification-profiles">Specification profiles</a>)
      </li>

      <li><strong>Identifier:</strong>
      "profile-action-shape-post"</li>

      <li><strong>Name:</strong> POST RDF described by a OSLC
      Resource Shape to the Action resource</li>

      <li>
        <strong>Contains:</strong> <a href=
        "#pattern-empty-body">HTTP request with empty body
        ("pattern-http-empty-body")</a>, <a href=
        "#pattern-resource-shape">HTTP request with Resource Shape
        to describe the request body
        ("pattern-http-resource-shape")</a>
      </li>

      <li>
        <strong>Used by:</strong> <a href=
        "https://tools.oasis-open.org/version-control/browse/wsvn/oslc-ccm/trunk/specs/change-mgt-actions.html">
        OSLC Change Management 3.0 (working draft)</a> (under
        evaluation)
      </li>
    </ul>

    <p>To meet the constraints of this profile, Action bindings
    MUST use one of the following Core Actions'
    interaction patterns:</p>

    <ul>
      <li>
        <a href="#pattern-empty-body"></a>
      </li>

      <li>
        <a href="#pattern-resource-shape"></a>
      </li>
    </ul>

    <p>The following additional constraints are imposed on action
    bindings, regardless of the interaction pattern used:</p>

    <ul>
      <li>The <code>oslc:requestURI</code> object
      MUST be the URL of the action resource that
      links to it.</li>

      <li>The <code>http:mthd</code> object MUST
      be <code>http-methods:POST</code>.</li>

      <li>The bindings MUST adhere to the standard
      restrictions on <code>http:Request</code> resources for
      simple specification profiles in <a href=
      "#constructing-http-requests">Appendix A: Constructing HTTP
      requests from http:Request resources</a>
      </li>
    </ul>

    <p>Known adopters of this profile:</p>

    <ul>
      <li>OSLC Change Management <a href=
      "http://open-services.net/wiki/change-management/State-Transitions-for-Change-Requests/#CM-Actions-with-the-Core-Workgroup-Actions-Proposal">
        3.0 example</a> (Note: the number 3.0 is a current
        best-guess; it might theoretically change)
      </li>
    </ul>
    </section>

    <section id="profile_automation_request">
    <h4>Profile: Create an Automation Request</h4>

    <ul>
      <li>
        <strong>Specification profile</strong> (See <a href=
        "#specification-profiles">Specification profiles</a>)
      </li>

      <li><strong>Identifier:</strong>
      "profile-automation-request"</li>

      <li><strong>Name:</strong> Create an Automation Request</li>

      <li>
        <strong>Contains:</strong> <a href=
        "#pattern-autoreq">Automation Request
        ("pattern-automation-request")</a>
      </li>

      <li>
        <strong>Used by:</strong> <a href=
        "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#OSLC-Actions-and-Automation">
        OSLC Automation 2.1</a>
      </li>
    </ul>

    <p>To meet the constraints of this profile, action bindings
    MUST use the following Core Actions'
    interaction pattern:</p>

    <ul>
      <li>
        <a href="#pattern-autoreq"></a>
      </li>
    </ul>

    <p>The following additional constraints are imposed on action
    bindings:</p>

    <ul>
      <li>The bindings MUST adhere to the standard
      restrictions on <code>http:Request</code> resources for
      simple specification profiles in <a href= "#constructing-http-requests"></a>
      </li>
    </ul>

    <p>Known adopters of this profile:</p>

    <ul>
      <li>
        <a href=
        "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#OSLC-Actions-and-Automation">
        OSLC Automation 2.1</a>
      </li>
    </ul>
    </section>
    </section>
    </section>

    <section id="constructing-http-requests" class="appendix">
    <h2>Constructing an HTTP request from an http:Request resource</h1>

    <p>HTTP requests are described in <a href=
    "http://www.w3.org/Protocols/rfc2616/rfc2616.html">RFC2616</a>
    (and other documents referenced by that one, and any documents
    that later supersede it).</p>

    <p>The <a href="http://www.w3.org/TR/HTTP-in-RDF10/">HTTP
    Vocabulary in RDF</a> provides a mapping between RDF terms and
    HTTP concepts. (This specification takes that vocabulary with
    one change, as follows: the value type of the http:requestURI
    is expected to be an RDF URI, not a string literal).</p>

    <p>This appendix is an interpretation of how to use those two
    documents together to construct an HTTP request based on an
    http:request resource. It is expressed in normative
    language.</p>

    <p>As specification profiles can require that providers offer
    action bindings that don't use some of these features, then
    consumers MAY decide not to implement all of
    these features. However, if a consumer has not implemented one
    of these features then they <strong>MUST NOT</strong> attempt
    to use a binding that uses that feature. For example, if a
    consumer has not implemented support for the
    <code>http:headers</code> property, then it <strong>MUST
    NOT</strong> attempt to construct and submit an HTTP request
    for a binding that contains that property.</p>

    <p>When constructing and sending an HTTP request based on an
    <code>http:Request</code> object, a consumer
    MUST:</p>

    <ul>
      <li>use the HTTP version specified by the
      <code>http:httpVersion</code> property.</li>

      <li>use the HTTP method specified by the
      <code>http:mthd</code> property.</li>

      <li>use the request URI specified by
      <code>http:requestURI</code>.</li>

      <li>include the headers specified by the
      <code>http:headers</code> property, if present.</li>
    </ul>

    <p>The interaction patterns referencing this appendix will
    specify how to construct the request body.</p>

    <p>Ordinarily the response to this request will be one of the
    following, although any status code allowed by HTTP is
    permitted. Consumers should note that status codes are
    extensible, and hence <a href=
    "http://tools.ietf.org/html/rfc2616#section-6.1.1">HTTP
    requires applications to understand the generic 1xx-5xx status
    code classes</a>, even if it also checks for specific status
    codes it needs to take action on, in order to gracefully handle
    the introduction of new status codes in the future.</p>

    <ul>
      <li>200 (OK) to indicate that the action has completed</li>

      <li>201 (Created) to indicate that the request resulted in
      the creation of a new resource; the Location response header
      provides the URL of the newly created resource.<br></li>

      <li>202 (Accepted) to indicate that the request has been
      queued and will be dealt with at a later time, at which point
      it might succeed or fail.

        <ul>
          <li>The <a href=
          "http://tools.ietf.org/html/rfc2616#section-10.2.3">HTTP
          specification</a> suggests returning a monitor to track
          the status of the execution, but provides no standard
          definition for such a monitor. If OSLC providers use the
          202 status code, they can consider using the OSLC
          Automation Specification's mechanisms, so that clients
          have a known pattern to code for.
          </li>
        </ul>
      </li>

      <li>4xx or 5xx status code to indicate failure.</li>
    </ul>

    <p>Depending upon the <a href=
    "#interaction-patterns">interaction pattern</a> within which a
    request is made, the HTTP status code might or might not give
    the status of the consumer's desired result (successfully
    completing an action). For example, the interaction pattern
    might require the consumer to use the <a href=
    "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0/">OSLC
    Automation specification</a>'s mechanisms to <a href=
    "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0/#State-and-Verdict-properties">
    monitor the action's progress and success/failure</a>.</p>
  </section>
  </section>

  <section id="standard-restrictions-on-httprequest-resources-for-simple-specification-profiles">
      <h2>Standard restrictions on http:Request resources for simple
          specification profiles</h2>

    <p>This section is here for specification profiles to
    conveniently restrict <code>http:Request</code> resources to
    simple requests, without having to repeat these restrictions in
    every profile that uses them. These restrictions only apply to
    specification profiles that explicitly reference this section.
    Implementations not governed by a specific profile, or governed
    by profiles that do not include these restrictions, can ignore
    this list.</p>

    <p>When these restrictions are included in a specification
    profile, the providers MUST, for each action
    linked to from an <code>oslc:action</code> predicate, provide
    at least one binding that:</p>

    <ul>
      <li>does NOT include the <code>http:headers</code>
      property</li>

      <li>specifies "1.1" as the value of the
      <code>http:httpVersion</code> property</li>

      <li>specifies the <code>http:requestURI</code> value as a
      URI, NOT a literal</li>
    </ul>

    <p>Consumers supporting this profile MAY
    decide not to implement support for bindings that do not adhere
    to these restrictions. However, if they do not implement
    support for bindings that do not meet these restrictions the
    consumers <strong>MUST NOT</strong> attempt to execute such
    bindings. That is, in that case they MUST
    check that the value of these properties is as stated in these
    restrictions.</p>
  </section>

  <section id="changes-to-oslc-core-vocabulary">
    <h3>Changes to OSLC Core vocabulary</h3>

    <p>These are the additions that this specification makes to the
    <a href="http://open-services.net/wiki/core/CoreVocabulary/">OSLC Core
    Vocabulary</a>.</p>

    <ul>
      <li>Predicates</li>

      <li><code>oslc:binding</code>. Description: The binding of
      some abstract action (the semantics of a process or
      operation) onto a more concrete interaction pattern or
      endpoint(s). For example, it can link an oslc:Action to a
      description of the messages (e.g. HTTP) that must be
      exchanged in order to perform the action. In OSLC Core
      Actions it is expected that the object will be of type
      http:Request, oslc:Dialog, or oslc:CreationFactory, but this
      is not necessarily the case.</li>

      <li><code>oslc:action</code>. Description: A link from any
      resource to an action that is available when the response is
      formed to execute on that subject resource. It is expected
      that the object will be of type oslc:Action, and will contain
      at least one oslc:binding predicate, but this is not
      necessarily the case.</li>

      <li>
        <code>oslc:executes</code>. Context: <a href=
        "http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#Future-actions">
        Automation 2.1 future actions</a> section. Description:
        Link from a currently available action to its corresponding
        future action.
      </li>

      <li>
        <code>oslc:futureAction</code>. Context: <a href=
        "#future-actions">future actions</a> section. Description:
        Link to an action that will become available at a future
        time, possibly on another resource. For example, a future
        action on an Automation Plan can become available after a
        corresponding Automation Request is created, or after it
        completes; or a resource shape can use it to describe
        actions that clients can expect to be available on
        resources that the shape applies to, for example those
        created by a particular creation factory.
      </li>

      <li><code>oslc:finalStatusLocation</code>. Description: The
      location at which the final status of a process, operation or
      action will be available. The meaning of any particular value
      of this predicate must be defined by an appropriate
      specification. For example, the OSLC Core Actions
      specification defines that if the value of this predicate is
      the URI http:StatusCode then the final status is to be taken
      from the HTTP response status code of a request that is
      described by the subject resource. OSLC Core Actions also
      defines the meaning of oslc:Dialog, oslc:ActionDialog and
      oslc-automation:AutomationResult in this context.</li>

      <li>Classes:</li>

      <li><code>oslc:Action</code>. Description: An Action provides
      a representation of an action, process or operation that can
      be executed against the subject resource, for example start
      or stop.</li>

      <li>Individuals:</li>

      <li><code>oslc:ActionDialog</code>. Description: An
      individual that represents that a dialog is to be used
      (oslc:usage) as a dialog to execute an oslc:Action. When the
      dialog is completed, the action's execution has been
      completed. (This is the added value on top of merely
      identifying a resource as rdf:type oslc:Dialog. This is in
      contrast to oslc-automation:DeferredExecutionDialog, which
      can be used as part of executing an action, but after the
      dialog completes the consumer has more steps to take.) The
      OSLC Core Actions specification defines additional status
      information that can be returned by dialogs used in this
      way.</li>
    </ul>
  </section>

  <section  id="conformance"></section>
  </section>

  <section class='appendix informative'>
    <h2>Acknowledgements</h2>

    <p>Many thanks to the various OASIS Core TC and Open Project members and other
    key contributors and reviewers.</p>
  </section>

  <section class='appendix informative'>
    <h2>Change History</h2>

    <p>The change history is up to the editors to insert a brief
    summary of changes, ordered by most recent changes first and
    with heading from which public draft it has been changed
    from.</p><!--
        <section>
                <h2>Detailed history</h2>
<!== <blockquote><em><a href="http://sspeiche.github.io/respec/examples/oslc/template-spec.html">Working Draft</a></em></blockquote> -->
    <!--
                <ul>
                        <li>2014-10-20 - Provide history, prefer autogen from SCM tool...conclude with initials (SS)</li>
                </ul>
        </section>-->
  </section>
</body>
</html>

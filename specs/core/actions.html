<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="description"
      content="This document provides a means of advertising actions (RESTful HTTP operations) that can be performed on a Linked Data
    resource."
    />
    <title>OSLC Actions</title>
    <script
      src="https://cdn.jsdelivr.net/gh/oasis-tcs/tab-respec@v2.1.18/builds/respec-oasis-common.min.js"
      async=""
      class="remove"
    ></script>
    <script type="text/javascript">
      var respecConfig = {
        specStatus: "WD",
        revision: "01",

        license: "cc-by-4",

        additionalLicenses: [
          {
            licenseName: "Apache License 2.0",
            licenseURI: "https://www.apache.org/licenses/LICENSE-2.0",
          },
        ],

        // Only include h1 and h2 level
        maxTocLevel: 2,

        shortName: "actions",
        conformanceLabelPrefix: "Actions",

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "https://raw.githack.com/oslc-op/oslc-specs/master/specs/core/actions.html",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // includePermalinks: true,

        chairs: [
          {
            name: "Jim Amsden",
            mailto: "jamsden@us.ibm.com",
            company: "IBM",
            companyURL: "http://www.ibm.com/",
          },
          {
            name: "Andrii Berezovskyi",
            mailto: "andriib@kth.se",
            company: "KTH",
            companyURL: "https://www.kth.se/en",
          },
        ],
        editors: [
          {
            name: "Martin Pain",
            mailto: "martinpain@uk.ibm.com",
            company: "IBM",
            companyURL: "http://ibm.com/",
          },
          {
            name: "Samuel Padgett",
            mailto: "spadgett@us.ibm.com",
            company: "IBM",
            companyURL: "http://ibm.com/",
          },
        ],

        wg: "OASIS Open Services for Lifecycle Collaboration (OSLC) OP",
        wgShortName: "oslc-op",
        wgURI: "https://github.com/oslc-op/oslc-specs",

        namespaces: [
          {
            href: "http://open-services.net/ns/core#",
            prefix: "oslc",
          },
        ],

        localBiblio: {},
      };
    </script>
  </head>

  <body>
    <section id="abstract">
      This document provides a means of advertising actions (RESTful HTTP operations) that can be performed on a Linked
      Data resource.
    </section>

    <section id="sotd">
      <em>Early Working Draft: formating into respec and aligning with 3.0 principles</em>
    </section>

    <section id="toc"></section>

    <section id="intro">
      <h2>Introduction</h2>

      <section id="what-are-actions" class="informative">
        <h3>What are actions?</h3>

        <p>
          This specification provides a means of advertising actions that can be performed on (or in the context of) a
          specific resource. For example, a
          <a
            href="http://open-services.net/wiki/change-management/State-Transitions-for-Change-Requests/#CM-Actions-with-the-Core-Workgroup-Actions-Proposal"
          >
            change request can have a "resolve" action or other state transitions</a
          >. Providers implementing this specification allow consumers to list and select actions that can be executed
          on a given resource <em>R</em> without needing to understand <em>R</em>'s type, properties, lifecycle, etc.
          See <a href="#what-do-consumers-need-to-know">What do consumers need to know?</a>. Each action provides a few
          primary pieces of information: "what does this action do?", "how do I execute this action?", and "how do I
          determine if the action succeeded or failed?". These are described in the
          <a href="#implConform">normative specification sections</a> below.
        </p>

        <p>[[Image:Actions-Overview-Questions.png]]</p>

        <p>
          Those questions are answered by action bindings. The action can have multiple bindings in order to provide
          compatibility with more than one type of consumer, or to support multiple interaction patterns (for example,
          programmatic execution in addition to execution via a delegated UI dialog). Each of the different bindings
          provided by a single action must be <em>semantically equivalent</em> - that is, they must each achieve the
          same thing, just in a different way and possibly at a different point in time - although they may not be
          <em>semantically identical</em>, because of differing side effects or details.
        </p>

        <p>The scenarios that this specification enables are listed on the [[Actions 2.0 Scenarios]] page.</p>
      </section>

      <section id="high-level-interaction-model" class="informative">
        <h3>High level interaction model</h3>

        <ul>
          <li>Providers annotate resources with actions.</li>

          <li>
            Consumers discover available actions on existing resources.

            <ul>
              <li>
                Domain-specific or profile-specific clients (the normal case) do so as described in and/or constrained
                by the appropriate specification(s) and/or profile(s) (for example, a profile provided by a domain
                specification); they need to understand whatever interaction pattern(s) the profile includes in order to
                successfully invoke actions that comply with it.
              </li>

              <li>
                Generic (cross-domain) clients might rely only on the entirety of Core Actions (this specification), and
                be able to display and/or invoke actions from many resource types and interaction patterns.
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <section id="what-do-consumers-need-to-know" class="informative">
        <h3>What do consumers need to know?</h3>

        <p>
          By using this explicit, loosely-coupled description of actions that are available on a given resource R,
          consumers <em>do not</em> need to understand:
        </p>

        <ul>
          <li>the <code>rdf:type</code> of R, or the domain that defines it</li>

          <li>the native lifecycle of R</li>

          <li>the properties of R unrelated to Actions, or the meaning of their values</li>
        </ul>

        <p>instead, the consumer only needs to know:</p>

        <ul>
          <li>the URI of R</li>

          <li>how to find the actions and their bindings that exist on R (as defined by this specification)</li>

          <li>how to execute those bindings (as defined by this specification)</li>

          <li>
            how to determine the success/failure of its request to execute the action (as defined by this specification)
          </li>
        </ul>

        <p>
          Therefore this specification frees the execution of these actions from domain specifics, instead providing a
          common point of interoperability between multiple domain specifications.
        </p>
      </section>

      <section id="domain-specific-consumers" class="informative">
        <h3>Domain-specific consumers</h3>

        <p>
          The first-order concern of domain specifications is <em>consumers written to that specification</em>. Domain
          specifications provide one or more specification profiles for the consumers to support. Those profile(s)
          define the minimum subset of this specification that the consumer must implement. The consumer itself is not
          aware of specification profiles at run time -- it is a design-time decision about what interaction patterns to
          implement with what (if any) restrictions, and how to document those design-time decisions.
        </p>

        <p>
          The process that a consumer supporting a given profile (whether or not that profile was provided by a domain
          specification) would follow to find resources with actions it is capable of consuming is:
        </p>

        <ul>
          <li>
            Decide what the set of interesting resources is. It might be one or many, depending upon the usage scenario.
          </li>

          <li>
            For each interesting resource:

            <ul>
              <li>
                Find <a href="#oslc-action-discovery">available actions</a> by looking for the <code>oslc:action</code>
                predicate on the resource
              </li>

              <li>
                For each such action

                <ul>
                  <li>
                    Find the bindings for that action by looking for the <code>oslc:binding</code> predicate on the
                    action.
                  </li>

                  <li>
                    For each action binding:

                    <ul>
                      <li>
                        For each interaction pattern that is supported by the consumer (which must include, at a
                        minimum, the interaction patterns required by the chosen profile):

                        <ul>
                          <li>
                            Determine if this consumer is compatible with that binding, by determining whether the
                            binding uses that interaction pattern and whether it adheres to any restrictions on the
                            bindings that this consumer can execute (e.g. any restrictions specified against that
                            interaction pattern in the profile that the consumer was implemented against).
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>

                  <li>
                    Note: At least one interaction pattern must match on a binding for the consumer to be compatible
                    with that binding. It is theoretically possible that multiple interaction patterns may match one
                    binding if interaction patterns that extend those in 2.0 are defined in certain ways, but in the 2.0
                    specification at most one interaction pattern matches any single binding.
                  </li>
                </ul>
              </li>

              <li>
                If at least one of the bindings is compatible with this consumer, then the action is compatible with
                this consumer.
              </li>
            </ul>
          </li>

          <li>Do whatever the client is coded to do.</li>
        </ul>

        <p>
          The process such a client would follow to <em>execute</em> any action it is capable of consuming is usually to
          form and make an HTTP request, but some interaction patterns dictate a different process. The instructions for
          forming and making the request are found by following <code>oslc:binding</code> link(s) and examining the
          object resources.
        </p>

        <ul>
          <li>
            Given the action to execute and the binding(s) for that action that the consumer is compatible with (found
            using the process above)
          </li>

          <li>
            If more than one binding is compatible with the consumer, choose one using whatever criteria the consumer
            prefers. e.g. it can have an order of preference (decided at implementation time) based on the interaction
            patterns' cost of execution (e.g. time, resources), or the desired interaction with the user (e.g. dialogs,
            or ability to execute at a later time).
          </li>

          <li>
            Follow the instructions of the selected interaction pattern to execute the action via the chosen binding.
            For example, if the binding is an <code>http:Request</code> resource, form the HTTP request from it.
          </li>
        </ul>

        <p>
          Note: no mention is made of how many HTTP requests are required to retrieve the Actions/bindings/etc. data
          mentioned, since that is implementation-dependent. <a href="#best-practices">Best practices</a> suggest
          minimizing them, especially when UI presentation performance is important.
        </p>
      </section>

      <section id="providers" class="informative">
        <h3>Providers</h3>

        <p>
          The second-order concern of domain specifications is <em>providers written to that specification</em>. The
          process such a provider would follow to <em>expose</em> resources with actions its domain-specific clients are
          capable of consuming is:
        </p>

        <ul>
          <li>
            Decide what the set of interesting resources is.

            <ul>
              <li>The most likely case is resources owned/exposed by the provider itself.</li>
            </ul>
          </li>

          <li>
            For each interesting resource:

            <ul>
              <li>
                Find any existing actions that the provider can add a new binding for

                <ul>
                  <li>
                    The action that the binding is for must be <em>semantically equivalent</em> to the provider's action
                    to be exposed, where equivalence is defined by the provider of the action. (There is no
                    loosely-coupled means of determining semantic equivalence between providers, other than when two
                    bindings are already on the same <code>oslc:Action</code>. So usually new bindings can only be added
                    to existing actions by the same provider that created the bindings already on the action, or some
                    implementation-specific means would have to exist for the two providers to agree that the two
                    bindings are semantically equivalent).
                  </li>
                </ul>
              </li>

              <li>
                Add the provider's action to be exposed, either as a new <code>oslc:binding</code> link or as a new
                <code>oslc:action</code> link.
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <section id="generic-or-cross-domain-consumers" class="informative">
        <h3>Generic or cross-domain consumers</h3>

        <p>
          Domain specifications often care little about consumers <em>not</em> written to that particular specification,
          beyond adhering to basic HTTP and Linked Data principles. Core specifications, in effect, enable cross-domain
          consumers.
        </p>

        <p>
          The process such a consumer would follow to <em>find</em>
          resources with actions it is capable of consuming, and
          <em>executing</em> those, is the same as for a domain-specific consumer, but where the interaction patterns
          supported by the consumer are as wide a set as the implementation allows, rather than being based on a
          specification profile. A generic consumer could, for example, look at all actions (<code>oslc:action</code>
          predicates) across a set of resources, present those to a user, and let the user select one or more to invoke.
          The only restriction on the set of interaction patterns is the set of those understood by the consumer code,
          since there is no single domain specification or profile involved.
        </p>
      </section>

      <section id="templates" class="informative">
        <h3>Templates</h3>

        <p>
          One particular usage pattern for Actions is their use as <em>templates</em>, especially by schedulers. An
          analogy is a partially filled-out form, for example a drug prescription, that one copies and submits (renews)
          multiple times. It is not always easy, given one of those forms, to distinguish between the original and the
          copies; they have nearly identical content, but they are used very differently. The original is used to
          manufacture new copies, and each copy is "traded" for a set quantity and type of medicine.<br />
        </p>

        <p>
          The same pattern occurs with schedulers: during a "configuration" phase, a form is filled out (for future use)
          and saved; later in time, during one or more "execution" or "use" phases, a copy of the saved form is
          submitted in order to cause a result such as executing an Action. The resource acting as the saved form and
          the copies made from it have very similar representations, but distinct identifiers (URIs). The copying
          process is usually accomplished by submitting a representation (of the resource acting as the template) to a
          creation factory, which responds to successful requests with a newly minted URI (identifying the new copy).
          Creation factories implemented via HTTP POST have considerable discretion in how they use the input
          representation, and in some cases (like
          <a href="http://open-services.net/wiki/automation">OSLC Automation</a>) the act of creation may carry with it
          side effects, like execution of an Automation Request. There is nothing specific to OSLC Automation in the
          template usage pattern, however; indeed, readers might well recognize a similar pattern in saved queries and
          favorite lists on many Web sites. Hence, the
          <a href="#interaction-patterns">interaction patterns</a> described later can generally each be used as part of
          a template pattern at a higher level of abstraction.
        </p>
      </section>
    </section>

    <section id="terms">
      <h2>Terminology</h2>

      <dl>
        <dt>Action</dt>

        <dd>
          Linked Data-based hypertext describing an end -- the desired semantics -- and some means to accomplish that
          end via HTTP-based interaction pattern(s) that may or may not also involve user interaction. Although the
          term's use in this specification is primarily to actions available when the response is formed, that limit
          does not come from this definition. Action resources can be used to describe other varieties, like past,
          future, or potential actions; enabling this additional flexibility in the definition is intentional, and it
          has been exploited already by at least the
          <a href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/">
            Automation domain</a
          >.
        </dd>

        <dt>Action binding</dt>

        <dd>
          A means of executing an action, or instructions for executing an action. Each action may have multiple action
          bindings to allow the action to support multiple interaction patterns. Each action binding uses an interaction
          pattern and specifies values (e.g. URL and request body contents) that the consumer must apply to that
          interaction pattern to execute that particular action.
        </dd>

        <dt>Interaction pattern</dt>

        <dd>
          An abstract definition of how a consumer and provider interact in order to execute an action. The definition
          includes a rule consumers use to recognize that an action binding uses the interaction pattern, instructions
          for sending messages, and instructions that consumers use to determine the results. For a simple interaction
          pattern using a single-request HTTP flow, determining the result can be as simple as inspecting the HTTP
          status code.
        </dd>

        <dt>
          <a href="#specification-profiles">Specification profiles</a>
        </dt>

        <dd>
          A named, coherent subset of a specification, often used in a specific domain, like
          <a href="http://open-services.net/wiki/change-management">Change Management</a> or
          <a href="http://open-services.net/wiki/automation">Automation</a>. An actions
          <em>specification profile</em> includes one or more <em>interaction patterns</em> for which each
          <em>Action</em> resource governed by that <em>profile</em> must provide an <em>Action binding</em>. The
          additional constraints simplify the range of code clients are required to implement, making it cheaper and
          easier to adopt. This is a specification-only concept, not a runtime concept.
        </dd>

        <dt>Provider</dt>

        <dd>
          For the purposes of the specification, an OSLC Actions provider is any OSLC implementation that serves
          resources of type oslc:Action or that serves action bindings, irrespective or whether it links to them from
          its owns resources or from resources hosted by other OSLC implementations.
        </dd>

        <dt>Consumer</dt>

        <dd>
          For the purposes of this specification, an OSLC Actions consumer is any OSLC implementation that can use
          resources of type oslc:Action to execute that action using its <em>action bindings</em>.
        </dd>
      </dl>
    </section>

    <section id="intended-audience" class="informative">
      <h2>Intended audience</h2>

      <p>
        This section is non-normative; it provides a guide as to which sections of the specification it is important for
        different audiences to understand and comply with.
      </p>

      <ul>
        <li>
          <strong>Implementors of OSLC consumers</strong> - To reduce implementation effort, implementations may choose
          to be compliant with only a subset of this specification. To support interoperability between implementations
          that do so it is recommended that consumers pick one or more
          <em><a href="#specification-profiles">specification profiles</a></em> and support, as a minimum, the subset of
          this specification included in those profiles.
        </li>

        <li>
          <strong>Implementors of OSLC providers</strong> - To reduce implementation effort, implementations may choose
          to be compliant with only a subset of this specification. To support interoperability between implementations
          that do so it is recommended that providers pick one or more
          <em><a href="#specification-profiles">specification profiles</a></em> and ensure that every action that they
          provide has at least one <em>Action binding</em> that falls within the constraints of each <em>profile</em>.
        </li>

        <li>
          <strong>Authors of specifications that re-use Action resources</strong> - It is recommended that domain
          specifications reusing Action resources select a
          <em><a href="#specification-profiles">specification profile</a></em> that implementations of the domain
          specification should support as a minimum. Such specifications can refer to a profile that is defined or
          referenced in this specification, or may define their own. Such specifications may also want to define
          additional interaction patterns, but are advised to reuse or extend the ones defined in this specification if
          possible, to aid interoperability.
        </li>
      </ul>
    </section>

    <section class="informative">
      <h2>Motivation</h2>

      <div class="note">
        TODO: fill in motivation
      </div>
    </section>

    <section id="concepts" class="informative">
      <h2>Basic Concepts</h2>

      <div class="note">
        TODO: fill in basic concepts (tease out of intro)
      </div>
    </section>

    <section id="implConform">
      <h2>Implementation Conformance</h2>

      <section id="re-use-by-domain-specs">
        <h3>Re-use by domain specifications</h3>

        <p>
          Domain specifications re-using this specification SHOULD make their readers aware of
          <a href="#best-practices">Best Practices</a> for representing actions and their related resources.<br />
        </p>

        <p>
          Domain specifications re-using this specification are strongly <strong>RECOMMENDED</strong> to require at
          least one specification profile for interoperability within the target domain. They SHOULD re-use the profiles
          defined or referenced in this specification where possible, or they MAY define new specification profile(s)
          when no existing profile meets their needs. The working groups defining them must consult with OSLC Core
          before defining new profiles, to determine if they are better added to Core or kept separate.
        </p>

        <p>
          Domain specifications re-using this specification MAY add new constraints beyond the ones here. Domain
          specifications re-using this specification <strong>MUST NOT</strong> weaken absolute constraints (MUST, MUST
          NOT) in this specification.
        </p>

        <p>
          Domain specifications re-using this specification MAY define new predicates beyond the ones here that link to
          actions not available when the response is formed. Likewise they MAY define new
          <a href="#types-of-actions">action types</a>, as
          <a href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/"
            >OSLC Automation 2.1</a
          >
          does for
          <a
            href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#Teardown-action-type"
          >
            teardown actions</a
          >; widely applicable action types SHOULD be allocated (by the Core working group) within the OSLC Core
          vocabulary.
        </p>

        <p>
          Domain specifications re-using this specification MUST comply with requirements imposed by later sections in
          this specification, for example those in
          <a href="#recognizing-patterns">recognizing interaction patterns</a> and
          <a href="#profiles-other">specification profiles</a>. The preceding list of examples might be incomplete;
          domain specification authors are responsible for finding and understanding all requirements levied on them in
          other sections.
        </p>
      </section>

      <section id="oslc-action-discovery">
        <h3>Discovering the actions available from a resource</h3>

        <p>
          Any resource MAY link to any number of Actions, using the <code>oslc:action</code> predicate as shown in the
          graphic below. The <code>oslc:action</code> predicate links to actions
          <em>available when the response is formed</em>. (In a distributed system, clients can lose race conditions
          that result in an action that appears as "available" having its execution requests rejected. However, it is
          not expected that actions will change frequently.)
        </p>
      </section>

      <section id="action-resources">
        <h3>Action resources</h3>

        <p>
          All resources in this specification, such as Actions, action bindings, and HTTP requests, MAY be represented
          as either blank nodes or URI-identified resources, and when identified by URIs either hash or non-hash URIs
          MAY be used.
        </p>

        <p>[[Image:Actions-Finding-Actions-From-Resources.png]]</p>
      </section>

      <section id="types-of-actions">
        <h3>Types of actions</h3>

        <p>
          Action resources identify what type of actions they are, so that consumers can know how to choose an action
          (for programmatic selection) or how to display an action (for selection by a user). For loose integration,
          some general action types are defined in this specification, and types applicable to individual domains are
          defined in specifications for those domains (for example,
          <a href="http://open-services.net/wiki/change-management">OSLC Change Management</a> and
          <a href="http://open-services.net/wiki/automation">OSLC Automation</a>). This specification lists some known
          action sub-types in <a href="#action-subtypes">Resources: Action subtypes</a>.
        </p>

        <p>
          Action types are identified by <code>rdf:type</code> values, e.g. <code>oslc-automation:TeardownAction</code>,
          which SHOULD all be <code>rdfs:subClassOf</code> <code>oslc:Action</code>. Since informal OSLC Core guidance
          states that providers cannot depend upon client-side inferencing, action representations are multi-typed: they
          MUST contain <code>oslc:Action</code> as one type, and MAY (usually do, in practice) contain additional types
          that convey more specific semantics necessary for programmatic consumption. The additional type URIs MAY
          belong to any vocabulary or namespace, however working groups in need of new types should consult with Core
          before defining new actions outside the Core namespace. Widely applicable action types should be allocated (by
          the Core working group) within the OSLC Core vocabulary.
        </p>
        <pre>
<code>&lt; http://example.com/sa/2314?stopREST &gt; a oslc:Action, oslc-automation:TeardownAction ;     # This

&lt; http://example.com/sa/2314?stopREST &gt; a              oslc-automation:TeardownAction ;     # NOT this
</code>
</pre>

        <p>Action types should be at a level of abstraction suitable for human and/or programmatic consumption.</p>

        <p>
          Implementations <strong>MUST NOT</strong> assume that actions with the same action types are semantically
          <em>identical</em>. Actions SHOULD use a combination of both standardised and (if needed) non-standardised
          types to make the identification of its type more specific. The standardised types allow loosely-coupled
          integration, and the more specific non-standard types allow comparison between actions and value-add for
          consumers that do know about the non-standard terms at implementation time. (However, as stated earlier in
          this paragraph, implementations cannot assume that actions with exactly the same set of
          <code>rdf:type</code> values are identical - they are only as equivalent as those types define.)
        </p>

        <blockquote>
          <p>
            As a hypothetical example, two actions could both identify themselves as <code>ns:DeletionAction</code>, but
            one could delete a child resource of the current context, and one could delete the context itself. It is
            more useful to (some) consumers if the actions identify themselves as being of-type
            <code>[oslc:Action, ns:DeletionAction, x:DeleteDelegateResource]</code> and
            <code>[oslc:Action, ns:DeletionAction, x:DeleteCurrentResourceAction]</code>, respectively. This is so that
            the standardised types allow loosely-coupled integration, and the specific non-standard types allow
            comparison between actions and value-add for consumers that do know about the non-standard terms at
            implementation time.
          </p>
        </blockquote>
      </section>

      <section id="executing-actions">
        <h3>Action bindings: instructions for executing available actions</h3>

        <p>
          Each <a href="#oslc-action-discovery">available action</a> contains one or more
          <code>oslc:binding</code> predicates, each of which links to a resource containing instructions for executing
          the action, such as the
          <a href="http://www.w3.org/TR/HTTP-in-RDF10/#RequestClass">HTTP request resource</a>
          (<code>http:Request</code>) shown below; the <a href="#Resource-Action">resource shape</a> allows zero
          bindings in other cases.<br />
        </p>

        <p>
          A consumer executes an action by following a single interaction pattern, applying information supplied in the
          action binding to the pattern. Out of the patterns that it supports, the consumer MUST use a pattern whose
          recognition rule is matched by the binding. If multiple patterns match (theoretically possible, but not
          currently specified), the consumer MAY use any interaction pattern whose recognition rule is matched by the
          action binding. This specification permits the use of resources with types in addition to those defined in
          interaction patterns in this specification, but it assigns them no meaning and when they are used
          interoperability will be reduced. Consumers MUST tolerate other resource types, but MAY ignore them.
        </p>

        <p>[[Image:Actions-Request-Linkage.png]]</p>

        <p>
          Each binding describes a means that the consumer can use to execute the action, by matching one or more
          interaction patterns and supplying data needed to perform it. Each of the bindings linked to from a single
          Action MUST be semantically equivalent -- the different bindings are different means of achieving the same
          desired result, within the bounds of what the Action's type(s) require and prohibit. However, the different
          bindings MAY (and almost always will) source any parameters from different sources (e.g. some use a dialog),
          MAY have different numbers of parameters, MAY be used to execute the action at different times (e.g. some can
          be used to schedule it for execution at a later time), and MAY have different side effects unless its types'
          semantics specifically prohibit them.
        </p>

        <p>
          The consumer picks a binding based on which interaction pattern(s) the consumer understands and which one it
          wants to use. The consumer then executes the action in the manner defined by the interaction pattern.
        </p>
      </section>

      <section id="future-actions">
        <h3>Future actions</h3>

        <p>
          This specification defines a predicate for discovering actions that are not available when the response is
          formed but that might become available at some point in the future, possibly on a related resource. See
          <a href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/"
            >OSLC Automation 2.1</a
          >'s associated scenarios for example uses specific to the Automation domain, and the paragraph below on
          resource shapes for another. Domain specifications SHOULD re-use <code>oslc:futureAction</code>
          rather than inventing their own new term, when the semantics are compatible. This specification also defines a
          <code>oslc:executes</code> predicate for linking from a currently available action to a corresponding future
          action; this was also motivated by Automation 2.1's scenarios.
        </p>

        <blockquote>
          <p>
            Non-normative note: feedback on draft specifications indicated more general scenarios exist outside the
            Automation domain, that could be satisfied by re-using existing Core capabilities if Core Actions was
            explicit on how to do so.
          </p>
        </blockquote>

        <p>
          Resource shapes can be used as a general way to expose the set of actions that a resource is capable of
          supporting but cannot be executed at the point in time when action discovery is occurring. Existing resources
          can link to a shape, for example via <code>oslc:instanceShape</code>. Creation factories can link to a shape
          describing the resources they are capable of manufacturing, via a <code>oslc:resourceShape</code> link from a
          <a href="http://open-services.net/bin/view/Main/OslcCoreSpecification">creation factory</a>. In each case, if
          the shape has one or more <code>oslc:futureAction</code> properties, then clients will expect that future
          action resources describe actions that the client might find linked to instances that the shape applies to,
          via the <code>oslc:action</code> predicate. That is, if a shape <code>S</code> applies to a resource
          <code>R</code>, and the shape <code>S</code> has a <code>oslc:futureAction</code> link to action
          <code>A</code>, then a client would expect that at some point during the existence of <code>R</code> that
          <code>R</code> would have an <code>oslc:action</code> link to an action <code>B</code> whose type list matches
          the type list of <code>A</code>. Similarly, <code>B</code> can link back to <code>A</code> when scenarios
          require this; for example, when it becomes necessary for a user to choose amongst future actions whose
          programmatic descriptions are very similar and schedule execution for a later time.
        </p>

        <blockquote>
          <p>
            Non-normative concrete example: if work order has a shape with a future action link to a "add log entry"
            action, then clients will expect that the work order is likely to have an <code>oslc:action</code> link to
            at least one "add log entry" action; if a work order creation factory <code>C</code> has a resource shape
            with a future action link to a "add log entry" action, then clients will expect that all work orders it
            creates are likely to have an <code>oslc:action</code> link to at least one "add log entry" action. Those
            "add log entry" actions might not be available all the time, or to every user, or on every work order the
            factory creates, and clients have to tolerate that; future actions are hints, not guarantees.
          </p>
        </blockquote>

        <p>
          This specification does not require that future actions have any bindings, that any bindings they do have are
          complete, or what the relationship is between any bindings present on a future action and those present when
          it becomes available for execution. Domain specifications re-using this specification MAY add such
          requirements.
        </p>
      </section>

      <section id="recognizing-patterns">
        <h3>Recognizing the interaction patterns used by each binding</h3>

        <p>Each interaction pattern defines how consumers should recognize it.</p>

        <p>
          Each action binding can match more than one interaction pattern, in which case the consumer can choose which
          one to use.
        </p>

        <p>When defining new interaction patterns in other specifications, the new patterns SHOULD either:</p>

        <ul>
          <li>
            extend an existing interaction pattern, but add in additional recognition conditions that use predicates
            under the control of the extending specification (to avoid incorrectly matching existing action bindings
            that do not follow the newly defined extension interaction pattern).

            <ul>
              <li>
                These extension interaction patterns MUST be 100% compatible with the patterns they extend -- that is,
                when Action bindings use these extension patterns the providers MUST support those bindings being
                executed as either the base or extension pattern.
              </li>

              <li>
                New interaction patterns that extend existing patterns MUST include an explicit reference to the
                extended pattern's recognition rule in the new pattern's recognition rule.
              </li>

              <li>They MAY also include a copy of the extended pattern's rule alongside that reference for clarity.</li>
            </ul>
          </li>
        </ul>

        <p>or:</p>

        <ul>
          <li>
            define a completely new interaction pattern that is recognized by (at least) an <code>rdf:type</code> value
            that is under the control of the extending specification.
          </li>
        </ul>
      </section>

      <section id="interaction-patterns">
        <h3>Interaction patterns</h3>

        <p>
          Consumers invoke actions to achieve a certain desired result, by choosing a specific binding and interaction
          pattern to construct one or more messages. A single action can have multiple bindings, and a single binding
          can potentially be used with multiple interaction patterns. Some interaction patterns always consist of a
          single message, but others permit or require multiple messages to achieve the same desired result. This
          distinction becomes critical when a consumer is trying to determine whether or not its
          <strong>desired result</strong> has been achieved, based on message responses - that is, what the
          <strong>final status</strong> of the action's execution is.<br />
        </p>

        <p>
          When using interaction patterns that always consist of a single HTTP message flow, consumers expect the HTTP
          status code to <strong>equate</strong> to the success or failure of the desired result (the final status of
          executing the action): if a success status code (2xx class) is returned, consumers interpret that to mean that
          the action ran <strong>successfully</strong>. Single-message interaction pattern definitions SHOULD avoid
          other interpretations.<br />
        </p>

        <p class="conformance">
          When using interaction patterns that sometimes or always consist of multiple HTTP message flows, in general
          consumers cannot expect "the" HTTP status code to <strong>equate</strong> to the success or failure of the
          desired result (the final status of executing the action), because the issue of which message's status code to
          use arises. Multi-message interaction patterns MUST define how a consumer unambiguously determines the final
          status of its desired result from the messages.
        </p>

        <p>Similar considerations apply to non-HTTP interaction patterns, although none are defined in Actions 2.0.</p>

        <blockquote>
          <p>
            Non-normative note: One consequence of this is that multi-message interaction patterns cannot inherit from
            single-message patterns, because of the contradiction that arises in a consumer's interpretation of the
            result of its messages. In the presence of certain <strong>implementation assumptions</strong> it is
            sometimes possible to "mix" them, but this has been found to be complex and error-prone.
          </p>

          <p>
            Non-normative note: A single binding can potentially be used with multiple interaction patterns if a new IP
            is created whose recognition rule adds a required property to an existing IP. There are no known existent
            cases of this in practice as of this specification being finalized.
          </p>
        </blockquote>

        <p>Each interaction pattern specifies:</p>

        <ul>
          <li>
            A <strong>pattern recognition rule</strong> - the restrictions that bindings must adhere to in order for
            consumers to recognize that pattern as one a binding uses.
          </li>

          <li>Instructions for <strong>execution</strong> of a binding using that interaction pattern.</li>

          <li>
            Instructions for <strong>finding the final status</strong> of executing a binding using that interaction
            pattern.
          </li>

          <li>
            Optionally, <strong>additional provider constraints</strong> that must be adhered to when using that
            pattern.
          </li>
        </ul>

        <blockquote>
          <p>
            Non-normative note: specifying <code>oslc:usage</code> = <code>oslc:default</code> on at least one of an
            action's bindings can help consumers decide between bindings. This is useful whenever multiple bindings
            exist on the action and several bindings satisfy the recognition rule for the same interaction pattern. If
            the provider marks one as a default, consumers have a clearer choice.
          </p>
        </blockquote>

        <section id="patterns-final-status">
          <h4>Final execution status</h4>

          <p>
            The Actions vocabulary defines a predicate <code>oslc:finalStatusLocation</code> whose RDF object conveys
            instructions telling a consumer how to determine the actual result of using the interaction pattern.
          </p>

          <p>
            This specification defines the following values for the <code>oslc:finalStatusLocation</code> predicate, and
            their meanings when they are used. Other specifications may define additional values. Exactly one value must
            be present; if a provider implementation happens to work in such a way that multiple values would always
            give the same result and it wishes to cater to both sets of consumers, it needs to create one binding for
            each value as described in the note below.
          </p>

          <ul>
            <li>
              <code>http:StatusCode</code> is used when the HTTP 1.1 status code conveys the actual result. This
              includes the status code class processing defined in HTTP, that is that any 2xx status code means success,
              and so on. Only single-message interaction patterns can use this value.
            </li>

            <li>
              <code>oslc:Dialog</code> is used when the OSLC Core delegated dialog protocol determines how to determine
              the actual result, which uses a combination of the HTTP status code and the
              <code>oslc:results</code> output object.
            </li>

            <li>
              <code>oslc:ActionDialog</code> is used when the
              <a href="#action-dialog-results">action dialog</a> protocol determines how to determine the actual result,
              which uses a combination of the HTTP status code and the <code>oslc:results</code> output object.
            </li>

            <li>
              <code>oslc-automation:AutomationResult</code> is used when an Automation Result's
              <a
                href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0/#State-and-Verdict-properties"
              >
                state and verdict properties</a
              >
              convey the actual result. This is typically used for cases where providers expect an action's
              implementation to be long-running, and therefore to require an
              <a
                href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0/#Asynchronous-and-Synchronous-Automation-Execution"
              >
                asynchronous style</a
              >
              using multiple messages.
            </li>
          </ul>

          <p>Other values can be used, but some consumers will not understand them.</p>

          <blockquote>
            <p>
              Non-normative note: The final status location is defined in the binding's RDF (and is included in the
              pattern's recognition rule) - not just implied by which pattern is used - so that in future other
              interaction patterns can be defined that are identical to existing interaction patterns, except in the
              location of the final status. For example, if a provider always performs
              <a
                href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0/#Asynchronous-and-Synchronous-Automation-Execution"
              >
                synchronous execution of the Automation Request</a
              >
              and sets the response's status code to match the
              <a
                href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0/#State-and-Verdict-properties"
              >
                Automation Result's verdict</a
              >, and it wants to make its actions executable both by consumers that only understand OSLC Automation
              requests and by consumers that only understand standard HTTP requests, such a provider could create two
              bindings that differ only in the object of the <code>oslc:finalStatusLocation</code> triple. Core Actions
              provides no facility to avoid repeating the rest of the binding information, although standard RDF
              facilities can be used.
            </p>
          </blockquote>
        </section>

        <section id="pattern-empty-body">
          <h4>Pattern: HTTP request with empty body</h4>

          <p>
            This interaction pattern consists of the consumer making an HTTP request with a zero-length body to a URL
            specified by the provider to execute the action.
          </p>

          <ul>
            <li><strong>Interaction pattern</strong> (See <a href="#interaction-patterns">Interaction patterns</a>)</li>

            <li><strong>Identifier:</strong> "pattern-http-empty-body"</li>

            <li><strong>Name:</strong> HTTP request with empty body</li>

            <li>
              <strong>Contained in profile:</strong>
              <a href="#profile_POST_resource_shape"
                >POST RDF described by a OSLC Resource Shape to the Action resource ("profile-action-shape-post")</a
              >
            </li>
          </ul>

          <section id="pattern-recognition-rule">
            <h5>Pattern recognition rule</h5>

            <p>For any action binding that uses this interaction pattern:</p>

            <ul>
              <li>at least one <code>rdf:type</code> property MUST have the value <code>http:Request</code>, and</li>

              <li>the <code>http:body</code> property MUST have the value <code>rdf:nil</code>.</li>

              <li>
                the <code>oslc:finalStatusLocation</code> property MUST have the value <code>http:StatusCode</code>.
              </li>
            </ul>

            <p>A binding is deemed to use this pattern if it meets these restrictions.</p>

            <p>[[Image:Actions-Pattern-Empty-Body.png]]</p>

            <p>
              See
              <a href="http://open-services.net/wiki/core/Actions-2.0-Examples/#example-empty-body"
                >the Examples appendix</a
              >
              for a full RDF example.
            </p>
          </section>

          <section id="execution">
            <h5>Execution</h5>

            <p>
              To execute an action using this interaction pattern, a consumer uses the binding's properties to send a
              request as described in <a href="#constructing-http-requests"></a>, but with a Content-Length header with
              a value of zero, and an empty request body.
            </p>
          </section>
        </section>

        <section id="pattern-resource-shape">
          <h4>Pattern: HTTP request with Resource Shape to describe the request body</h4>

          <p>
            This interaction pattern allows an Action to describe the request body that it accepts in terms of an OSLC
            resource shape.
          </p>

          <ul>
            <li><strong>Interaction pattern</strong> (See <a href="#interaction-patterns">Interaction patterns</a>)</li>

            <li><strong>Identifier:</strong> "pattern-http-resource-shape"</li>

            <li><strong>Name:</strong> HTTP request with Resource Shape to describe the request body</li>

            <li>
              <strong>Contained in profile:</strong>
              <a href="#profile_POST_resource_shape"
                >POST RDF described by a OSLC Resource Shape to the Action resource ("profile-action-shape-post")</a
              >
            </li>
          </ul>

          <section id="pattern-recognition-rule_1">
            <h5>Pattern recognition rule</h5>

            <p>For any action binding that uses this interaction pattern:</p>

            <ul>
              <li>at least one <code>rdf:type</code> property MUST have the value of <code>http:Request</code>, and</li>

              <li>
                the <code>http:body</code> property MUST link to a resource with at least one <code>rdf:type</code> of
                <code>oslc:ResourceShape</code>.
              </li>

              <li>
                the <code>oslc:finalStatusLocation</code> property MUST have the value <code>http:StatusCode</code>.
              </li>
            </ul>

            <p>A binding is deemed to use this pattern if it meets these restrictions.</p>

            <p>[[Image:Actions-Pattern-Resource-Shape.png]]</p>

            <p>
              See
              <a href="http://open-services.net/wiki/core/Actions-2.0-Examples/#example-resource-shape"
                >the Examples appendix</a
              >
              for a full RDF example.
            </p>
          </section>

          <section id="execution_1">
            <h5>Execution</h5>

            <p>
              To execute an action using this interaction pattern, a consumer uses the binding's properties to send a
              request as described in <a href="#constructing-http-requests"></a>. The consumer constructs the HTTP body
              by finding or constructing an RDF resource that matches the defined resource shape and using an
              appropriate serialisation of that resource as the HTTP request body.
            </p>
          </section>
        </section>

        <section id="pattern-body-repn">
          <h4>Pattern: HTTP request with fixed body</h4>

          <p>
            This interaction pattern allows an action binding to provide a resource that is to be serialized as the
            request body.
          </p>

          <ul>
            <li><strong>Interaction pattern</strong> (See <a href="#interaction-patterns">Interaction patterns</a>)</li>

            <li><strong>Identifier:</strong> "pattern-http-fixed-body"</li>

            <li><strong>Name:</strong> HTTP request with fixed body</li>

            <li><strong>Contained in profiles:</strong> <em>(None)</em></li>
          </ul>

          <section id="pattern-recognition-rule_2">
            <h5>Pattern recognition rule</h5>

            <p>For any action binding that uses this interaction pattern:</p>

            <ul>
              <li>at least one <code>rdf:type</code> property MUST have the value <code>http:Request</code>, and</li>

              <li>
                the <code>http:body</code> property MUST link to a resource that meets these conditions:

                <ul>
                  <li>
                    at least one <code>rdf:type</code> property MUST have the value
                    <code>oslc-automation:ParameterInstance</code>, and
                  </li>

                  <li>
                    MUST have exactly one <code>rdf:value</code> property that links to the resource that is to be
                    serialised
                  </li>
                </ul>
              </li>

              <li>
                the <code>oslc:finalStatusLocation</code> property MUST have the value <code>http:StatusCode</code>.
              </li>
            </ul>

            <p>A binding is deemed to use this pattern if it meets these restrictions.</p>

            <p>[[Image:Actions-Pattern-Fixed-Body.png]]</p>

            <p>
              See
              <a href="http://open-services.net/wiki/core/Actions-2.0-Examples/#example-body-repn"
                >the Examples appendix</a
              >
              for a full RDF example.
            </p>
          </section>

          <section id="execution_2">
            <h5>Execution</h5>

            <p>
              To execute an action using this interaction pattern, a consumer uses the binding's properties to send a
              request as described in <a href="#constructing-http-requests"></a>. The consumer constructs the HTTP body
              by serializing the resource that is the object of the <code>rdf:value property</code> of the
              <code>oslc-automation:ParameterInstance</code> resource, and the consumer uses the HTTP
              <code>Content-Type</code> header to specify the media type used on the request to execute the action.
            </p>

            <blockquote>
              <p>
                Non-normative note: The consumer will have to choose a media type that is appropriate. Appropriate media
                types could be detected from the <code>http:headers</code> property on the
                <code>http:Request</code> resource if present, or from the <code>Content-Type</code> used on previous
                responses the consumer has received from the provider (for example, when retrieving the
                <code>rdf:value</code>'s representation), or (when the binding specifies a POST request) from an
                <code>Accept-Post</code> response header from the resource linked to by the
                <code>http:requestURI</code> property.
              </p>
            </blockquote>
          </section>
        </section>

        <section id="pattern-autoreq">
          <h4>Pattern: Automation request</h4>

          <p>This interaction pattern allows an Action to be executed by creating an Automation Request.</p>

          <ul>
            <li><strong>Interaction pattern</strong> (See <a href="#interaction-patterns">Interaction patterns</a>)</li>

            <li><strong>Identifier:</strong> "pattern-automation-request"</li>

            <li><strong>Name:</strong> Automation request</li>

            <li>
              <strong>Contained in profile:</strong>
              <a href="#profile_automation_request">Create an Automation Request ("profile-automation-request")</a>
            </li>
          </ul>

          <section id="pattern-recognition-rule_3">
            <h5>Pattern recognition rule</h5>

            <p>For any action binding that uses this interaction pattern:</p>

            <ul>
              <li>at least one <code>rdf:type</code> property MUST have the value <code>http:Request</code>, and</li>

              <li>
                the <code>http:body</code> property MUST link to a resource that meets these conditions:

                <ul>
                  <li>
                    at least one <code>rdf:type</code> property MUST have the value
                    <code>oslc-automation:AutomationRequest</code>.
                  </li>
                </ul>
              </li>

              <li>
                the <code>oslc:finalStatusLocation</code> property MUST have the value
                <code>oslc-automation:AutomationResult</code>.
              </li>
            </ul>

            <p>A binding is deemed to use this pattern if it meets these restrictions.</p>

            <blockquote>
              <p>
                Non-normative note: the <code>rdf:type</code> property requirement implies that only RDF representations
                are compatible with this pattern, as would be expected from its dependence on RDF resources defined in
                OSLC Automation.<br />
              </p>
            </blockquote>

            <p>[[Image:Actions-Pattern-Automation-Request.png]]</p>

            <p>
              See
              <a href="http://open-services.net/wiki/core/Actions-2.0-Examples/#example-autoreq"
                >the Examples appendix</a
              >
              for a full RDF example.
            </p>
          </section>

          <section id="additional-provider-constraints">
            <h5>Additional provider constraints</h5>

            <p>In addition, action bindings using this interaction pattern:</p>

            <ul>
              <li>
                MUST specify POST as the value of the <code>http:mthd</code> property in the action binding's
                <code>http:Request</code> resource
              </li>

              <li>
                MUST specify an
                <code>oslc-automation:AutomationRequest</code> that conforms to the requirements placed on those
                resources by the
                <a href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0">
                  OSLC Automation specification</a
                >.
              </li>

              <li>
                MUST include an <code>oslc-automation:executesAutomationPlan</code> property on the Automation Request,
                pointing to the Automation Plan that this action binding executes.
              </li>

              <li>
                are <strong>RECOMMENDED</strong> to use the <code>http:requestURI</code> property of the action
                binding's <code>http:Request</code> resource to link to a standard creation factory (described by a
                <code>oslc:CreationFactory</code> resource) that accepts Automation Requests for the appropriate service
                provider, so clients can obtain the creation factory's URI from the <code>oslc:creation</code> property.
              </li>

              <li>
                MUST accept any valid Automation Requests for the Automation Plan executed by this action binding (i.e.
                it must not rely on the consumer submitting exactly the Automation Request that was provided by the
                Action), <em>if and only if</em> a GET on the <code>http:requestURI</code> returns a resource with an
                <code>rdf:type</code> of <code>oslc:CreationFactory</code>.
              </li>
            </ul>
          </section>

          <section id="execution_3">
            <h5>Execution</h5>

            <p>
              When executing an action binding according to this interaction pattern, a consumer follows the execution
              instructions of the <a href="#pattern-body-repn">HTTP request with fixed body</a> interaction pattern,
              with the exception that the consumer constructs the HTTP body content from the Automation Request. The
              consumer may construct this body content by merely serialising the Automation Request that has been
              provided, or they may alter that Automation Request to provide additional or different parameter values if
              they understand the parameters that the linked Automation Plan takes, or they may find another way to
              construct an Automation Request for that Automation Plan (e.g. by using a stored Automation Request
              created earlier, or by finding a
              <a
                href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#Template-Dialog-interaction-pattern"
              >
                deferred-execution creation dialog</a
              >
              to create the Automation Request).
            </p>

            <p>
              The client's desired result is to successfully complete execution of the action; creating the Automation
              Request is merely the first step. The status of this desired result is determined using the corresponding
              Automation Result's
              <a
                href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#State-and-Verdict-properties"
              >
                state and verdict properties</a
              >, as would be the case with any other Automation Request, not by using the HTTP status codes.
              <a
                href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#Asynchronous-and-Synchronous-Automation-Execution"
              >
                Automation permits both</a
              >
              single-message and multiple-message interactions, but the client MUST use the state and verdict for
              determining the
              <a
                href="http://open-services.net/wiki/core/Exposing-arbitrary-actions-on-RDF-resources/#Interaction-patterns"
              >
                status of the client's desired result</a
              >
              when the HTTP status codes indicate that the creation was successful.
            </p>
          </section>
        </section>

        <section id="pattern-immed-dialog">
          <h4>Pattern: Delegated UI dialog for immediate execution</h4>

          <p>
            This interaction pattern consists of the consumer displaying a delegated UI dialog to a user for them to
            perform the action immediately, and waiting for the action to be completed or cancelled before returning to
            the consumer.
          </p>

          <ul>
            <li><strong>Interaction pattern</strong> (See <a href="#interaction-patterns">Interaction patterns</a>)</li>

            <li><strong>Identifier:</strong> "pattern-action-dialog"</li>

            <li><strong>Name:</strong> Delegated UI dialog for immediate execution</li>

            <li><strong>Contained in profiles:</strong> <em>(None)</em></li>
          </ul>

          <section id="pattern-recognition-rule_4">
            <h5>Pattern recognition rule</h5>

            <p>For any action binding that uses this interaction pattern:</p>

            <ul>
              <li>at least one <code>rdf:type</code> property MUST have the value <code>oslc:Dialog</code>, and</li>

              <li>at least one <code>oslc:usage</code> property MUST have the value <code>oslc:ActionDialog</code>.</li>

              <li>
                the <code>oslc:finalStatusLocation</code> property MUST have the value <code>oslc:ActionDialog</code>.
              </li>
            </ul>

            <p>A binding is deemed to use this pattern if it meets these restrictions.</p>

            <p>[[Image:Actions-Pattern-Action-Dialog.png]]</p>

            <p>
              See
              <a href="http://open-services.net/wiki/core/Actions-2.0-Examples/#example-immed-dialog"
                >the Examples appendix</a
              >
              for a full RDF example.
            </p>
          </section>

          <section id="action-dialog-results">
            <h5>Execution</h5>

            <p>
              To execute an action binding using this interaction pattern, a consumer follows the instructions in the
              <a href="http://open-services.net/bin/view/Main/OslcCoreSpecification#Delegated_User_Interface_Dialogs">
                OSLC Core Delegated UI specification</a
              >
              to display the dialog. The dialog is responsible for everything necessary to execute the action, including
              but not limited to accepting any parameters and displaying any output, and SHOULD be displayed until the
              action is completed or cancelled. The dialog MUST return a <code>oslc:results</code> object conforming to
              the <a href="#resource-results">resource shape for action dialog results</a>.
            </p>

            <p>
              If the HTTP status code indicates success, the consumer determines whether or not the action succeeded
              using the output <code>oslc:results</code> object's verdict property. (This is different than selection
              dialogs and creation dialogs, which return a URI to a domain- or implementation-specific resource - action
              dialogs only have to return a verdict whose URI identifies the final status of the action's execution).
            </p>

            <ul>
              <li><code>oslc-automation:passed</code> means that the action was executed successfully</li>

              <li><code>oslc-automation:failed</code> means that the action was attempted but failed</li>

              <li>
                <code>oslc-automation:canceled</code> means that the dialog was cancelled, whether or not the action was
                attempted
              </li>
            </ul>

            <blockquote>
              <p>
                Non-normative note: This interaction pattern is intended to be used where the actions will complete very
                quickly, otherwise the user is stuck with the delegated UI dialog on the screen waiting for the action
                to complete.
              </p>

              <p>
                Non-normative note: The dialog displays and gives the user the option to start the action, and should be
                displayed until the action is completed or cancelled. It may give the option to cancel before the action
                has started and/or while the action is running. <code>oslc-automation:canceled</code> is used for either
                of those cases.
              </p>
            </blockquote>
          </section>
        </section>

        <section id="pattern-dialog-delayed-execution">
          <h4>Pattern: Delegated UI dialog for later execution</h4>

          <p>
            This pattern is defined by the OSLC Automation specification:
            <a
              href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#Template-Dialog-interaction-pattern"
            >
              Deferred execution dialog interaction pattern</a
            >.
          </p>

          <ul>
            <li><strong>Interaction pattern</strong> (See <a href="#interaction-patterns">Interaction patterns</a>)</li>

            <li><strong>Identifier:</strong> "pattern-delegated-execution-dialog"</li>

            <li><strong>Name:</strong> Delegated UI dialog for later execution</li>

            <li><strong>Contained in profiles:</strong> <em>(None)</em></li>
          </ul>
        </section>

        <section id="pattern-creation-factory">
          <h4>Pattern: Automation Creation Factory</h4>

          <p>
            This pattern is defined by the OSLC Automation specification:
            <a
              href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#pattern-autoreq-creation-factory"
            >
              Creation Factory interaction pattern</a
            >.
          </p>

          <ul>
            <li><strong>Interaction pattern</strong> (See <a href="#interaction-patterns">Interaction patterns</a>)</li>

            <li><strong>Identifier:</strong> "pattern-automation-creation-factory"</li>

            <li><strong>Name:</strong> Automation Creation Factory</li>

            <li><strong>Contained in profiles:</strong> <em>(None)</em></li>
          </ul>
        </section>
      </section>
    </section>

    <section id="resources">
      <h2>Resources</h2>

      <p>This section defines the resources of the Actions specification.</p>

      <section id="actions-namespace">
        <h3>Actions Namespace</h3>

        <p>The namespace used for resources and properties <em>defined in this specification</em> is as follows:</p>

        <ul>
          <li>Namespace URI: <code>http://open-services.net/ns/core#</code></li>

          <li>Default Prefix: <code>oslc</code></li>
        </ul>
      </section>

      <section id="other-namespaces">
        <h3>Other namespaces</h3>

        <p>
          This specification re-uses content from namespaces defined by other specifications. This specification assumes
          the following mappings from prefixes to namespaces, in addition to those suggested in
          <a href="http://open-services.net/bin/view/Main/OSLCCoreSpecAppendixA">OSLC Core</a>.
        </p>

        <table>
          <thead>
            <tr>
              <th><em>Prefix</em></th>

              <th><em>Namespace</em></th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><code>http</code></td>

              <td>
                <a href="http://www.w3.org/2011/http#">http://www.w3.org/2011/http#</a>
              </td>
            </tr>

            <tr>
              <td><code>http-methods</code></td>

              <td>
                <a href="http://www.w3.org/2011/http-methods#">http://www.w3.org/2011/http-methods#</a>
              </td>
            </tr>

            <tr>
              <td><code>oslc-automation</code></td>

              <td>
                <a href="http://open-services.net/ns/auto#">http://open-services.net/ns/auto#</a>
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <section id="Resource-Action">
        <h3>Resource: Action</h3>

        <ul>
          <li><strong>Name:</strong> <code>Action</code></li>

          <li>
            <strong>Description:</strong> An Action provides a representation of an action, process or operation that
            can be executed against the subject resource, for example start or stop.
          </li>

          <li>
            <strong>Type URI:</strong>
            <a href="http://open-services.net/ns/core#Action"><code>http://open-services.net/ns/core#Action</code></a>
          </li>
        </ul>

        <section id="action-properties">
          <h4>Action Properties</h4>

          <table>
            <thead>
              <tr>
                <th><em>Prefixed Name</em></th>

                <th><em>Occurs</em></th>

                <th><em>Read-only</em></th>

                <th><em>Value-type</em></th>

                <th><em>Representation</em></th>

                <th><em>Range</em></th>

                <th><em>Description</em></th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td><em>OSLC Core:</em> Common Properties</td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>
              </tr>

              <tr>
                <td>
                  <a href="http://purl.org/dc/terms/title">dcterms:title</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral"> XMLLiteral</a>
                </td>

                <td>N/A</td>

                <td>N/A</td>

                <td>
                  Title (reference: Dublin Core) of the resource, represented as rich text using XHTML content. SHOULD
                  include only content that is valid and suitable inside an XHTML &lt;div&gt; element.
                </td>
              </tr>

              <tr>
                <td>
                  <a href="http://purl.org/dc/terms/description">dcterms:description</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Zero-or-one">Zero-or-one</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral"> XMLLiteral</a>
                </td>

                <td>N/A</td>

                <td>N/A</td>

                <td>
                  Descriptive text (reference: Dublin Core) about the resource, represented as rich text using XHTML
                  content. SHOULD include only content that is valid and suitable inside an XHTML &lt;div&gt; element.
                </td>
              </tr>

              <tr>
                <td>
                  <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">rdf:type</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#One-or-many">One-or-many</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://open-services.net/ns/core#Resource">Resource</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Reference">Reference</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Any">Any</a>
                </td>

                <td>The resource type URIs. At least one type MUST be <code>oslc:Action</code>.</td>
              </tr>

              <tr>
                <td><em>OSLC Core Actions:</em> Start of additional properties</td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>
              </tr>

              <tr>
                <td>
                  <a href="http://open-services.net/ns/core#binding">oslc:binding</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Zero-or-many">Zero-or-many</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://open-services.net/ns/core#AnyResource">AnyResource</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Either">Either</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Any">Any</a>
                </td>

                <td>
                  Instructions for executing the action. It is likely that the target resource will be an
                  <code>http:Request</code>, <code>oslc-automation:AutomationRequest</code>, or
                  <code>oslc:Dialog</code>, but that is not necessarily the case. Multiple occurrences of this property
                  MUST be different ways of achieving the same operation; they are semantically the same, but achieved
                  through different data or technologies or at different times.
                </td>
              </tr>

              <tr>
                <td>
                  <a href="http://open-services.net/ns/core#executes">oslc:executes</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Zero-or-one">Zero-or-one</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://open-services.net/ns/core#AnyResource">AnyResource</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Either">Either</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Any">Any</a>
                </td>

                <td>
                  Link to the future action, if any, that a currently available action realizes. It is likely that the
                  target resource will be an <code>oslc:Action</code>, but that is not necessarily the case. See
                  <a href="#future-actions">future actions</a> for example uses.
                </td>
              </tr>
            </tbody>
          </table>
        </section>

        <section id="action-subtypes">
          <h4>Action subtypes</h4>

          <p>The following is an informal, and potentially incomplete, registry of action subtypes:</p>

          <ul>
            <li><code>oslc-automation:TeardownAction</code> - tears down an already-deployed resource</li>
          </ul>

          <p>Before defining new subtypes, please <a href="#types-of-actions">coordinate with the community</a>.</p>
        </section>
      </section>

      <section id="property-oslc-action">
        <h3>Common Property: oslc:action</h3>

        <p>
          In addition to resource definitions, this specification defines one property below that can occur in any RDF
          resource. This property is defined to be a well-known way of finding available actions on any resource.
          Resource types may want to specify their own property/ies instead, but this one is defined as a sensible
          default.
        </p>

        <p>
          <font color="red"
            >Automation WG proposes that this property be moved to Core's
            <a href="http://open-services.net/bin/view/Main/OSLCCoreSpecAppendixA">"common properties" appendix</a>
            during the finalization phase.</font
          >
        </p>

        <table>
          <thead>
            <tr>
              <th><em>Prefixed Name</em></th>

              <th><em>Occurs</em></th>

              <th><em>Read-only</em></th>

              <th><em>Value-type</em></th>

              <th><em>Representation</em></th>

              <th><em>Range</em></th>

              <th><em>Description</em></th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><em>OSLC Core:</em> Common Properties</td>

              <td></td>

              <td></td>

              <td></td>

              <td></td>

              <td></td>

              <td></td>
            </tr>

            <tr>
              <td>
                <a href="http://open-services.net/ns/core#action">oslc:action</a>
              </td>

              <td>
                <a href="http://open-services.net/ns/core#Zero-or-many">Zero-or-many</a>
              </td>

              <td>Unspecified</td>

              <td>
                <a href="http://open-services.net/ns/core#AnyResource">AnyResource</a>
              </td>

              <td>
                <a href="http://open-services.net/ns/core#Either">Either</a>
              </td>

              <td>
                <a href="http://open-services.net/ns/core#Any">Any</a>
              </td>

              <td>
                An action that the provider asserts is available for execution by clients
                <em>at the time the representation was formed</em>. In a distributed system, clients can lose race
                conditions that result in an "available"-appearing action's execution requests being rejected. It is
                likely that the target resource will be an <code>oslc:Action</code>, but that is not necessarily the
                case;
                <a
                  href="http://open-services.net/wiki/core/Exposing-arbitrary-actions-on-RDF-resources/#executing-actions"
                >
                  when it is an <code>oslc:Action</code>, it will have at least one binding</a
                >
                since this predicate's definition requires that the action be available when the response is formed.
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <section id="resource-request">
        <h3>Resource: Request</h3>

        <p>
          Note: this resource is <strong>re-used</strong> by this specification, not defined by it. This specification
          defines the resource shape (how the
          <a href="http://www.w3.org/TR/HTTP-in-RDF10/#RequestClass">existing W3C vocabulary</a> is re-used and
          extended).
        </p>

        <ul>
          <li><strong>Name:</strong> <code>Request</code></li>

          <li>
            <strong>Description:</strong> A Request provides a representation of an HTTP request. (Reference: HTTP in
            RDF)
          </li>

          <li>
            <strong>Type URI:</strong>
            <a href="http://www.w3.org/2011/http#Request"><code>http://www.w3.org/2011/http#Request</code></a>
          </li>
        </ul>

        <section id="request-properties">
          <h4>Request Properties</h4>

          <table>
            <thead>
              <tr>
                <th><em>Prefixed Name</em></th>

                <th><em>Occurs</em></th>

                <th><em>Read-only</em></th>

                <th><em>Value-type</em></th>

                <th><em>Representation</em></th>

                <th><em>Range</em></th>

                <th><em>Description</em></th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td><em>OSLC Core:</em> Common Properties</td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>
              </tr>

              <tr>
                <td>
                  <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">rdf:type</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#One-or-many">One-or-many</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://open-services.net/ns/core#Resource">Resource</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Reference">Reference</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Any">Any</a>
                </td>

                <td>The resource type URIs. At least one type MUST be <code>http:Request</code>.</td>
              </tr>

              <tr>
                <td><em>HTTP in RDF:</em> Common properties</td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>
              </tr>

              <tr>
                <td>
                  <a href="http://www.w3.org/2011/http#requestURI">http:requestURI</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://open-services.net/ns/core#Resource">Resource</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Reference">Reference</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Any">Any</a>
                </td>

                <td>HTTP Request-URI for the request. (Reference: HTTP 1.1)</td>
              </tr>

              <tr>
                <td>
                  <a href="http://www.w3.org/2011/http#mthd">http:mthd</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://open-services.net/ns/core#Resource">Resource</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Reference">Reference</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Any">Any</a>
                </td>

                <td>
                  HTTP method for the request. The target resource SHOULD come from the
                  <a href="http://www.w3.org/2011/http-methods">http-methods</a> vocabulary. Many clients are likely to
                  support only widely used methods such as <a href="http://www.w3.org/2011/http-methods">POST</a>.
                </td>
              </tr>

              <tr>
                <td>
                  <a href="http://www.w3.org/2011/http#httpVersion">http:httpVersion</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
                </td>

                <td>Unspecified</td>

                <td>String</td>

                <td>N/A</td>

                <td>N/A</td>

                <td>
                  HTTP protocol version for the request. Providers would be wise to support HTTP 1.1 (value: "1.1") in
                  order to achieve interoperability in practice.
                </td>
              </tr>

              <tr>
                <td>
                  <a href="http://www.w3.org/2011/http#body">http:body</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://open-services.net/ns/core#AnyResource">AnyResource</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Either">Either</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Any">Any</a>
                </td>

                <td>
                  Parameters executing the action. It is likely that the target resource will be a
                  <code>oslc:ResourceShape</code>, <code>oslc-automation:ParameterInstance</code>, or an
                  <code>oslc-automation:AutomationRequest</code> but that is not necessarily the case.
                </td>
              </tr>

              <tr>
                <td>
                  <a href="http://open-services.net/ns/core#usage">oslc:usage</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Zero-or-many">Zero-or-many</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://open-services.net/ns/core#Resource">Resource</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Reference">Reference</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Any">Any</a>
                </td>

                <td>
                  Expected usage pattern for the resource. A value of <code>oslc:default</code> can also be used when
                  multiple bindings are present on a single action to hints to clients which is preferred.
                </td>
              </tr>

              <tr>
                <td><em>OSLC Core Actions:</em> Start of additional properties</td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>
              </tr>

              <tr>
                <td>
                  <a href="http://open-services.net/ns/core#finalStatusLocation">oslc:finalStatusLocation</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://open-services.net/ns/core#Resource">Resource</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Reference">Reference</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Any">Any</a>
                </td>

                <td>
                  How a consumer determines the status of its desired result (whether or not it has been achieved),
                  which possibly requires multiple message exchanges. It is likely that the value will be one of these
                  URIs: <code>oslc:Dialog</code>, <code>oslc:ActionDialog</code>, <code>http:StatusCode</code>, or an
                  <code>oslc-automation:AutomationResult</code>, but that is not necessarily the case.
                </td>
              </tr>
            </tbody>
          </table>

          <p>
            The <a href="http://www.w3.org/TR/HTTP-in-RDF10/">HTTP Vocabulary in RDF 1.0 W3C Working Draft</a> defines
            additional content for describing HTTP requests, beyond those listed above; only a subset of HTTP in RDF is
            used by Core Actions to address known scenarios. Implementations that need additional content SHOULD re-use
            the W3C vocabulary where possible instead of inventing their own, for example if specific headers are
            required, but client interoperability may be limited.
          </p>

          <blockquote>
            <blockquote>
              <p>
                Non-normative note: We have talked to the W3C members involved in writing this vocabulary about
                extending http:requestURI to allow to be a RDF link instead of a string literal whose (string) value
                happens to be a URI. Currently no new work is being done on the vocabulary, but there were no objections
                to the usage.
              </p>
            </blockquote>
          </blockquote>
        </section>
      </section>

      <section id="resource-results">
        <h3>Resource: results</h3>

        <p>
          This resource is returned by the
          <a href="#pattern-immed-dialog">delegated UI dialog for immediate execution</a> to indicate the status
          ("verdict") of the execution of the action.
        </p>

        <p>
          Note: this resource is <strong>re-used</strong> by this specification, not defined by it. This specification
          defines the resource shape (how the <a href="http://open-services.net/ns/core#results">existing type</a> is
          re-used and extended).
        </p>

        <ul>
          <li><strong>Name:</strong> <code>results</code></li>

          <li><strong>Description:</strong> The results from a delegated user interface (UI) dialog.</li>

          <li>
            <strong>Type URI:</strong>
            <a href="http://open-services.net/ns/core#results"><code>http://open-services.net/ns/core#results</code></a>
          </li>
        </ul>

        <table>
          <thead>
            <tr>
              <th><strong>Prefixed Name</strong></th>

              <th><strong>Occurs</strong></th>

              <th><strong>Read-only</strong></th>

              <th><strong>Value-type</strong></th>

              <th><strong>Representation</strong></th>

              <th><strong>Range</strong></th>

              <th><strong>Description</strong></th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>OSLC Core Actions Properties</td>

              <td></td>

              <td></td>

              <td></td>

              <td></td>

              <td></td>

              <td></td>
            </tr>

            <tr>
              <td>
                <a href="http://open-services.net/ns/auto#verdict"><code>oslc-automation:verdict</code></a>
              </td>

              <td>
                <a href="http://open-services.net/ns/core#One-or-many">One-or-many</a>
              </td>

              <td>true</td>

              <td>
                <a href="http://open-services.net/ns/core#Resource">Resource</a>
              </td>

              <td>
                <a href="http://open-services.net/ns/core#Reference">Reference</a>
              </td>

              <td>
                <a href="http://open-services.net/ns/core#Any">Any</a>
              </td>

              <td>
                URI of the verdict. Providers need to expose at least one standard URI for interoperability, but they
                can expose other more specific ones if needed as long as all URIs on a single result are semantically
                compatible. It is likely that the target resource will be one of the following, but that is not
                necessarily the case:
                <a href="http://open-services.net/ns/auto#failed"><code>oslc-automation:failed</code></a
                >, <a href="http://open-services.net/ns/auto#passed"><code>oslc-automation:passed</code></a
                >,
                <a href="http://open-services.net/ns/auto#canceled"><code>oslc-automation:canceled</code></a>
              </td>
            </tr>

            <tr>
              <td>
                <a href="http://open-services.net/ns/core#label"><code>oslc:label</code></a>
              </td>

              <td>
                <a href="http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
              </td>

              <td>true</td>

              <td>
                <a href="http://www.w3.org/2001/XMLSchema#string">String</a>
              </td>

              <td>N/A</td>

              <td>N/A</td>

              <td>
                Short label describing the result (verdict) of the action dialog, for example from an
                <a href="#pattern-immed-dialog">immediate execution action dialog</a>.
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <section id="Resource_ParameterInstance">
        <h3>Resource: ParameterInstance</h3>

        <p>
          Note: this resource is <strong>re-used</strong> by this specification, not defined by it. This specification
          defines the resource shape (how the
          <a href="http://open-services.net/ns/auto#ParameterInstance">existing type</a> is re-used and extended).
        </p>

        <ul>
          <li><strong>Name:</strong> <code>ParameterInstance</code></li>

          <li><strong>Description:</strong> A resource representing a HTTP entity-body instance.</li>

          <li><strong>Type URI</strong> <code>http://open-services.net/ns/auto#ParameterInstance</code></li>
        </ul>

        <section id="parameterinstance-properties">
          <h4>ParameterInstance Properties</h4>

          <table>
            <thead>
              <tr>
                <th><em>Prefixed Name</em></th>

                <th><em>Occurs</em></th>

                <th><em>Read-only</em></th>

                <th><em>Value-type</em></th>

                <th><em>Representation</em></th>

                <th><em>Range</em></th>

                <th><em>Description</em></th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td><em>OSLC Core:</em> Common Properties</td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>

                <td></td>
              </tr>

              <tr>
                <td>
                  <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">rdf:type</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#One-or-many">One-or-many</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://open-services.net/ns/core#Resource">Resource</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Reference">Reference</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Any">Any</a>
                </td>

                <td>
                  The resource type URIs. At least one type MUST be <code>oslc-automation:ParameterInstance</code>.
                </td>
              </tr>

              <tr>
                <td><code>rdf:value</code></td>

                <td>
                  <a href="http://open-services.net/ns/core#Exactly-one">Exactly-one</a>
                </td>

                <td>Unspecified</td>

                <td>
                  <a href="http://open-services.net/ns/core#AnyResource">AnyResource</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Either">Either</a>
                </td>

                <td>
                  <a href="http://open-services.net/ns/core#Any">Any</a>
                </td>

                <td>
                  The value of the parameter, either a resource or a typed literal. Untyped literals can be used in
                  place of string-typed literals.
                </td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
    </section>

    <section id="best-practices">
      <h2>Best Practices</h2>

      <section id="minimize-the-number-of-http-round-trips" class="informative">
        <h3>Minimize the number of HTTP round-trips</h3>

        <p>
          Actions will often be and/or link to inline resources, possibly anonymous ones (without their own URL, i.e.
          blank nodes). But they can be separate, addressable resources if needed. Since a client might need to retrieve
          Action descriptions, e.g. in a UI, in order to find the one with the correct type (if it is looking for a
          particular type of action), it is likely advantageous to minimize the number of HTTP round trips by returning
          the representation of all a resource's actions along with the resource's representation. The same pattern
          applies to <code>oslc:binding</code> object resources.
        </p>
      </section>
    </section>

    <section id="specification-profiles">
      <h2>Specification profiles</h2>

      <section id="specification-profiles-overview">
        <h3>Specification profiles overview</h3>

        <p>
          An <em>specification profile</em> is a coherent subset of this specification. A
          <em>specification profile</em> includes one or more <em>interaction patterns</em> for which each
          <em>Action</em> governed by that <em>profile</em> must provide an <em>Action binding</em>. The additional
          constraints simplify the range of code clients are required to implement, making it cheaper and easier to
          adopt. This is a specification-only concept, not a runtime concept.
        </p>

        <p>
          This specification is very general, broad and extensible. As such, writing consumer implementations that
          support the entire specification might require more effort than would be required to solve the narrower
          problem(s) of a specific domain's scenarios. To reduce the minimum amount of effort required, we define a
          number of <em>specification profiles</em> (hereafter, "profiles"), which specify subsets of the specification
          as a minimum base for interoperability between implementations of this specification.
        </p>

        <p>
          To be clear, the intention of profiles is to reduce the amount of the specification that consumers need to
          implement to be interoperable with providers. Therefore, it is intended that the profiles restrict the
          providers (by requiring them to provide, as a minimum, action bindings that conform to certain restrictions)
          so that consumers can include more assumptions about what they will find.
        </p>

        <p>
          Profiles are chosen at the time that an provider/consumer is implemented. They inform what subset of this
          specification is implemented. They are not a runtime concern. Interaction patterns are what clients match
          action bindings against at runtime; a provider's design-time choice of supported specification profiles
          determines which interaction patterns the implementation supports, and hence which clients it can successfully
          integrate with.
        </p>

        <section id="using-specification-profiles">
          <h3>Using specification profiles</h3>

          <p>
            Provider implementations SHOULD choose one or more profiles that they will comply with. To "comply with" a
            profile a provider MUST, for each Action resource served by that provider, provide
            <em>at least one</em> Action binding that meets the constraints of that profile - as well as meeting any
            other requirements imposed on a provider by that profile.
          </p>

          <p>
            Consumer implementations SHOULD choose one or more profiles to support. To "support" a profile a consumer
            MUST be able to recognize and execute all the interaction patterns included in the profile, and meet any
            other requirements imposed on a consumer by that profile. Consumers will work best when integrated with
            providers that comply with at least one of the profiles that they support.
          </p>
        </section>

        <section id="recognizing-profiles">
          <h3>Recognizing profiles</h3>

          <p>
            Providers SHOULD state, in their user or integration documentation, which profile(s) they comply with. This
            information SHOULD include the names of the profiles with hyperlinks or URL references to the specifications
            in which they were defined. (If only a subset of a provider's actions comply with a profile, the
            documentation SHOULD make it clear which subset that is).
          </p>

          <section id="why-are-profiles-only-identified-in-documentation-not-data" class="informative">
            <h4>Why are profiles only identified in documentation, not data?</h4>

            <p>
              Matching profiles is intended to be an implementation-time and integration configuration problem. When a
              user is deciding if two different components are compatible with each other, they will look at the
              documentation and see that a consumer supports a given set of profiles of the OSLC Actions specification.
              They will then look at the providers that they are considering using and see which profiles of this
              specification that they comply with. They should only expect the integrations to be successful where there
              is a match of at least one profile between the consumer and provider involved. The identifiers provided
              for the profiles are intended to allow the profiles to be referred to unambiguously in product
              documentation.
            </p>

            <p>
              It is possible that implementations that do not share a common profile may still work together, at least
              for some of their actions. For example, a provider may have some actions that have very simple Action
              bindings and some that have more complex ones. The simpler Action bindings may, on inspection, be seen to
              adhere to the restrictions of a given profile, even if that was not the intention of the provider. A
              consumer that supports that profile would then be able to execute the actions with the simpler Action
              bindings, even though the provider had not targeted itself at that profile. For this reason the profiles
              are not identified in the data, but instead implementations have to look at the Actions available and see
              if they comply with the interaction patterns and other restrictions that they support.
            </p>

            <p>
              In other words,
              <strong
                >compatibility between a consumer and a given Action binding is based on the interaction pattern being
                used and any subset or restriction of that pattern that the consumer is compatible with</strong
              >. Profiles merely guide consumers as to which interaction patterns (or restrictions thereof) they should
              implement, and to encourage providers to produce Action bindings that do not require complex consumers.
            </p>
          </section>
        </section>

        <section id="choosing-one-or-more-profiles-to-implement">
          <h3>Choosing one or more profiles to implement</h3>

          <p>
            When implementing a consumer or a provider, profile(s) SHOULD be chosen by considering the providers or
            consumers (respectively) that the implementation is to integrate with. This can be done by looking at
            specific implementations that already exist, or by using the profile identified by a domain specification
            that the implementations share, or by considering the likely capabilities of the implementations to be
            integrated.
          </p>

          <p>
            Most implementations of this specification will occur in the context of another specification, for a
            specific domain. In those cases, implementations SHOULD choose, as a minimum, the profile(s) required by
            that domain specification.
          </p>
        </section>

        <section id="profiles-other">
          <h3>Other specifications</h3>

          <p>
            Other specifications re-using Action resources are reminded that they have
            <a href="#re-use-by-domain-specs">obligations documented in other sections</a>.
          </p>
        </section>

        <section id="terminology_1">
          <h3>Terminology</h3>

          <ul>
            <li>
              <strong>specification profile</strong> (also "profile") - See <a href="#using-specification-profiles"></a>
            </li>

            <li>
              <strong>Comply with</strong> - See
              <a href="#using-specification-profiles">using specification profiles</a>
            </li>

            <li>
              <strong>Support</strong> - See <a href="#using-specification-profiles">using specification profiles</a>
            </li>

            <li>
              <strong>Constraints</strong>/<strong>requirements</strong> - An <em>specification profile</em> imposes
              constraints on Action bindings, and restrictions on providers and consumers. These are defined in the
              profile's definition.
            </li>
          </ul>
        </section>

        <section id="specification-profile-definitions">
          <h3>Specification profile definitions</h3>

          <section id="profile_POST_resource_shape">
            <h4>Profile: POST RDF described by a OSLC Resource Shape to the Action resource</h4>

            <ul>
              <li>
                <strong>Specification profile</strong> (See
                <a href="#specification-profiles">Specification profiles</a>)
              </li>

              <li><strong>Identifier:</strong> "profile-action-shape-post"</li>

              <li><strong>Name:</strong> POST RDF described by a OSLC Resource Shape to the Action resource</li>

              <li>
                <strong>Contains:</strong>
                <a href="#pattern-empty-body">HTTP request with empty body ("pattern-http-empty-body")</a>,
                <a href="#pattern-resource-shape"
                  >HTTP request with Resource Shape to describe the request body ("pattern-http-resource-shape")</a
                >
              </li>

              <li>
                <strong>Used by:</strong>
                <a
                  href="https://tools.oasis-open.org/version-control/browse/wsvn/oslc-ccm/trunk/specs/change-mgt-actions.html"
                >
                  OSLC Change Management 3.0 (working draft)</a
                >
                (under evaluation)
              </li>
            </ul>

            <p>
              To meet the constraints of this profile, Action bindings MUST use one of the following Core Actions'
              interaction patterns:
            </p>

            <ul>
              <li>
                <a href="#pattern-empty-body"></a>
              </li>

              <li>
                <a href="#pattern-resource-shape"></a>
              </li>
            </ul>

            <p>
              The following additional constraints are imposed on action bindings, regardless of the interaction pattern
              used:
            </p>

            <ul>
              <li>The <code>oslc:requestURI</code> object MUST be the URL of the action resource that links to it.</li>

              <li>The <code>http:mthd</code> object MUST be <code>http-methods:POST</code>.</li>

              <li>
                The bindings MUST adhere to the standard restrictions on <code>http:Request</code> resources for simple
                specification profiles in
                <a href="#constructing-http-requests"
                  >Appendix A: Constructing HTTP requests from http:Request resources</a
                >
              </li>
            </ul>

            <p>Known adopters of this profile:</p>

            <ul>
              <li>
                OSLC Change Management
                <a
                  href="http://open-services.net/wiki/change-management/State-Transitions-for-Change-Requests/#CM-Actions-with-the-Core-Workgroup-Actions-Proposal"
                >
                  3.0 example</a
                >
                (Note: the number 3.0 is a current best-guess; it might theoretically change)
              </li>
            </ul>
          </section>

          <section id="profile_automation_request">
            <h4>Profile: Create an Automation Request</h4>

            <ul>
              <li>
                <strong>Specification profile</strong> (See
                <a href="#specification-profiles">Specification profiles</a>)
              </li>

              <li><strong>Identifier:</strong> "profile-automation-request"</li>

              <li><strong>Name:</strong> Create an Automation Request</li>

              <li>
                <strong>Contains:</strong>
                <a href="#pattern-autoreq">Automation Request ("pattern-automation-request")</a>
              </li>

              <li>
                <strong>Used by:</strong>
                <a
                  href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#OSLC-Actions-and-Automation"
                >
                  OSLC Automation 2.1</a
                >
              </li>
            </ul>

            <p>
              To meet the constraints of this profile, action bindings MUST use the following Core Actions' interaction
              pattern:
            </p>

            <ul>
              <li>
                <a href="#pattern-autoreq"></a>
              </li>
            </ul>

            <p>The following additional constraints are imposed on action bindings:</p>

            <ul>
              <li>
                The bindings MUST adhere to the standard restrictions on <code>http:Request</code> resources for simple
                specification profiles in <a href="#constructing-http-requests"></a>
              </li>
            </ul>

            <p>Known adopters of this profile:</p>

            <ul>
              <li>
                <a
                  href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#OSLC-Actions-and-Automation"
                >
                  OSLC Automation 2.1</a
                >
              </li>
            </ul>
          </section>
        </section>
      </section>

      <section id="constructing-http-requests" class="appendix">
        <h2>Constructing an HTTP request from an http:Request resource</h2>

        <p>
          HTTP requests are described in <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">RFC2616</a> (and
          other documents referenced by that one, and any documents that later supersede it).
        </p>

        <p>
          The <a href="http://www.w3.org/TR/HTTP-in-RDF10/">HTTP Vocabulary in RDF</a> provides a mapping between RDF
          terms and HTTP concepts. (This specification takes that vocabulary with one change, as follows: the value type
          of the http:requestURI is expected to be an RDF URI, not a string literal).
        </p>

        <p>
          This appendix is an interpretation of how to use those two documents together to construct an HTTP request
          based on an http:request resource. It is expressed in normative language.
        </p>

        <p>
          As specification profiles can require that providers offer action bindings that don't use some of these
          features, then consumers MAY decide not to implement all of these features. However, if a consumer has not
          implemented one of these features then they <strong>MUST NOT</strong> attempt to use a binding that uses that
          feature. For example, if a consumer has not implemented support for the <code>http:headers</code> property,
          then it <strong>MUST NOT</strong> attempt to construct and submit an HTTP request for a binding that contains
          that property.
        </p>

        <p>
          When constructing and sending an HTTP request based on an <code>http:Request</code> object, a consumer MUST:
        </p>

        <ul>
          <li>use the HTTP version specified by the <code>http:httpVersion</code> property.</li>

          <li>use the HTTP method specified by the <code>http:mthd</code> property.</li>

          <li>use the request URI specified by <code>http:requestURI</code>.</li>

          <li>include the headers specified by the <code>http:headers</code> property, if present.</li>
        </ul>

        <p>The interaction patterns referencing this appendix will specify how to construct the request body.</p>

        <p>
          Ordinarily the response to this request will be one of the following, although any status code allowed by HTTP
          is permitted. Consumers should note that status codes are extensible, and hence
          <a href="http://tools.ietf.org/html/rfc2616#section-6.1.1"
            >HTTP requires applications to understand the generic 1xx-5xx status code classes</a
          >, even if it also checks for specific status codes it needs to take action on, in order to gracefully handle
          the introduction of new status codes in the future.
        </p>

        <ul>
          <li>200 (OK) to indicate that the action has completed</li>

          <li>
            201 (Created) to indicate that the request resulted in the creation of a new resource; the Location response
            header provides the URL of the newly created resource.<br />
          </li>

          <li>
            202 (Accepted) to indicate that the request has been queued and will be dealt with at a later time, at which
            point it might succeed or fail.

            <ul>
              <li>
                The <a href="http://tools.ietf.org/html/rfc2616#section-10.2.3">HTTP specification</a> suggests
                returning a monitor to track the status of the execution, but provides no standard definition for such a
                monitor. If OSLC providers use the 202 status code, they can consider using the OSLC Automation
                Specification's mechanisms, so that clients have a known pattern to code for.
              </li>
            </ul>
          </li>

          <li>4xx or 5xx status code to indicate failure.</li>
        </ul>

        <p>
          Depending upon the <a href="#interaction-patterns">interaction pattern</a> within which a request is made, the
          HTTP status code might or might not give the status of the consumer's desired result (successfully completing
          an action). For example, the interaction pattern might require the consumer to use the
          <a href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0/"
            >OSLC Automation specification</a
          >'s mechanisms to
          <a
            href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.0/#State-and-Verdict-properties"
          >
            monitor the action's progress and success/failure</a
          >.
        </p>
      </section>
    </section>

    <section id="standard-restrictions-on-httprequest-resources-for-simple-specification-profiles">
      <h2>Standard restrictions on http:Request resources for simple specification profiles</h2>

      <p>
        This section is here for specification profiles to conveniently restrict <code>http:Request</code> resources to
        simple requests, without having to repeat these restrictions in every profile that uses them. These restrictions
        only apply to specification profiles that explicitly reference this section. Implementations not governed by a
        specific profile, or governed by profiles that do not include these restrictions, can ignore this list.
      </p>

      <p>
        When these restrictions are included in a specification profile, the providers MUST, for each action linked to
        from an <code>oslc:action</code> predicate, provide at least one binding that:
      </p>

      <ul>
        <li>does NOT include the <code>http:headers</code> property</li>

        <li>specifies "1.1" as the value of the <code>http:httpVersion</code> property</li>

        <li>specifies the <code>http:requestURI</code> value as a URI, NOT a literal</li>
      </ul>

      <p>
        Consumers supporting this profile MAY decide not to implement support for bindings that do not adhere to these
        restrictions. However, if they do not implement support for bindings that do not meet these restrictions the
        consumers <strong>MUST NOT</strong> attempt to execute such bindings. That is, in that case they MUST check that
        the value of these properties is as stated in these restrictions.
      </p>
    </section>

    <section id="changes-to-oslc-core-vocabulary">
      <h3>Changes to OSLC Core vocabulary</h3>

      <p>
        These are the additions that this specification makes to the
        <a href="http://open-services.net/wiki/core/CoreVocabulary/">OSLC Core Vocabulary</a>.
      </p>

      <ul>
        <li>Predicates</li>

        <li>
          <code>oslc:binding</code>. Description: The binding of some abstract action (the semantics of a process or
          operation) onto a more concrete interaction pattern or endpoint(s). For example, it can link an oslc:Action to
          a description of the messages (e.g. HTTP) that must be exchanged in order to perform the action. In OSLC Core
          Actions it is expected that the object will be of type http:Request, oslc:Dialog, or oslc:CreationFactory, but
          this is not necessarily the case.
        </li>

        <li>
          <code>oslc:action</code>. Description: A link from any resource to an action that is available when the
          response is formed to execute on that subject resource. It is expected that the object will be of type
          oslc:Action, and will contain at least one oslc:binding predicate, but this is not necessarily the case.
        </li>

        <li>
          <code>oslc:executes</code>. Context:
          <a href="http://open-services.net/wiki/automation/OSLC-Automation-Specification-Version-2.1/#Future-actions">
            Automation 2.1 future actions</a
          >
          section. Description: Link from a currently available action to its corresponding future action.
        </li>

        <li>
          <code>oslc:futureAction</code>. Context: <a href="#future-actions">future actions</a> section. Description:
          Link to an action that will become available at a future time, possibly on another resource. For example, a
          future action on an Automation Plan can become available after a corresponding Automation Request is created,
          or after it completes; or a resource shape can use it to describe actions that clients can expect to be
          available on resources that the shape applies to, for example those created by a particular creation factory.
        </li>

        <li>
          <code>oslc:finalStatusLocation</code>. Description: The location at which the final status of a process,
          operation or action will be available. The meaning of any particular value of this predicate must be defined
          by an appropriate specification. For example, the OSLC Core Actions specification defines that if the value of
          this predicate is the URI http:StatusCode then the final status is to be taken from the HTTP response status
          code of a request that is described by the subject resource. OSLC Core Actions also defines the meaning of
          oslc:Dialog, oslc:ActionDialog and oslc-automation:AutomationResult in this context.
        </li>

        <li>Classes:</li>

        <li>
          <code>oslc:Action</code>. Description: An Action provides a representation of an action, process or operation
          that can be executed against the subject resource, for example start or stop.
        </li>

        <li>Individuals:</li>

        <li>
          <code>oslc:ActionDialog</code>. Description: An individual that represents that a dialog is to be used
          (oslc:usage) as a dialog to execute an oslc:Action. When the dialog is completed, the action's execution has
          been completed. (This is the added value on top of merely identifying a resource as rdf:type oslc:Dialog. This
          is in contrast to oslc-automation:DeferredExecutionDialog, which can be used as part of executing an action,
          but after the dialog completes the consumer has more steps to take.) The OSLC Core Actions specification
          defines additional status information that can be returned by dialogs used in this way.
        </li>
      </ul>
    </section>

    <section id="conformance"></section>

    <section class="appendix informative">
      <h2>Acknowledgements</h2>

      <p>Many thanks to the various OASIS Core TC and Open Project members and other key contributors and reviewers.</p>
    </section>

    <section class="appendix informative">
      <h2>Change History</h2>

      <p>
        The change history is up to the editors to insert a brief summary of changes, ordered by most recent changes
        first and with heading from which public draft it has been changed from.
      </p>
      <!--
        <section>
                <h2>Detailed history</h2>
<!== <blockquote><em><a href="http://sspeiche.github.io/respec/examples/oslc/template-spec.html">Working Draft</a></em></blockquote> -->
      <!--
                <ul>
                        <li>2014-10-20 - Provide history, prefer autogen from SCM tool...conclude with initials (SS)</li>
                </ul>
        </section>-->
    </section>
  </body>
</html>

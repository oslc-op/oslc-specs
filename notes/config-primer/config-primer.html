<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Configuration Management Primer Version 1.0</title>
    <meta charset="utf-8" />
    <meta
      name="description"
      content="This primer serves as a guide to the concepts in the specification, and through the use of simple examples, explains how versioning and configurations are represented, how and when local configurations and global configurations are used, and lists the elements that an implementation should consider."
    />

    <script
      src="https://cdn.jsdelivr.net/gh/oasis-tcs/tab-respec@v2.1.28/builds/respec-oasis-common.min.js"
      async
      class="remove"
    ></script>
    <script class="remove">
      var respecConfig = {
        shortName: "config-primer",
        specStatus: "PN",
        revision: "01",
        publishDate: "2021-12-16T12:00Z",
        // previousPublishDate: "2019-11-14",
        // previousMaturity: "PSD",

        thisVersion: "https://docs.oasis-open-projects.org/oslc-op/config-primer/v1.0/pn01/config-primer.html",
        prevVersion: null,
        latestVersion: "https://docs.oasis-open-projects.org/oslc-op/config/v1.0/oslc-config-mgt.html",
        latestSpecVersion: null,
        edDraftURI: null,

        // Other parts of multi-part spec
        additionalArtifacts: [],

        relatedWork: [
          {
            title: "OSLC Configuration Management Version 1.0. Part 1: Overview",
            href: "https://open-services.net/spec/config/latest",
          },
        ],

        localBiblio: {
          OSLCCore3: {
            title: "OSLC Core 3.0",
            href: "hhttps://open-services.net/spec/core/latest",
            authors: ["Jim Amsden", "S. Speicher"],
            status: "OASIS Standard",
            publisher: "OASIS",
          },
        },

        license: "cc-by-4",
        additionalLicenses: [
          {
            licenseName: "Apache License 2.0",
            licenseURI: "https://www.apache.org/licenses/LICENSE-2.0",
          },
        ],
        citationLabel: "OSLC-Config-Primer-1.0",
        maxTocLevel: 3,
        // conformanceLabelPrefix: "CP",
        // noConformanceStyling: 1,
        noConformanceTable: 1,
        // conformanceClauseStrength : 1,
        editors: [],

        // name of the OP
        wg: "OASIS Open Services for Lifecycle Collaboration (OSLC) OP",
        wgShortName: "oslc-op",
        chairs: [
          {
            name: "Jim Amsden",
            mailto: "jamsden@us.ibm.com",
            company: "IBM",
            companyURL: "https://www.ibm.com/",
          },
          {
            name: "Andrii Berezovskyi",
            mailto: "andriib@kth.se",
            company: "KTH",
            companyURL: "https://www.kth.se/en",
          },
        ],
        editors: [
          {
            name: "David Honey",
            mailto: "DavidHoney@uk.ibm.com",
            company: "IBM",
            companyURL: "https://www.ibm.com/",
          },
        ],
      };
    </script>
    <style>
      table,
      th,
      td {
        border: 1px solid #666;
        border-collapse: collapse;
      }
      table th,
      table td {
        padding: 5px; /* Apply cell padding */
      }

      hr {
        border: none;
        border-top: 1px double #666;
        color: #666;
        overflow: visible;
        height: 0px;
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>
        This primer serves as a guide to the concepts in the specification, and through the use of simple examples,
        explains how versioning and configurations are represented, how and when local configurations and global
        configurations are used, and lists the elements that an implementation should consider.
      </p>
    </section>

    <section id="toc"></section>
    <section id="sotd"></section>

    <section id="outline" class="level1">
      <h1>Outline</h1>
      <p>
        The OSLC Configuration Management specification is a reference for servers that want to expose configuration
        management to OSLC clients. However, the specification is not organized as a tutorial or introduction about how
        to implement an OSLC configuration management compliant server or adapter.
      </p>
      <p>
        This primer serves as a guide to the concepts in the specification, and through the use of simple examples,
        explains how versioning and configurations are represented, how and when local configurations and global
        configurations are used, and lists the elements that an implementation should consider. The specification
        remains the definitive source, and where this primer differs from the specification, the specification should be
        taken as the authoritative reference.
      </p>
    </section>
    <section id="motivation" class="level1">
      <h1>Motivation</h1>
      <section id="problem" class="level2">
        <h2>Problem</h2>
        <p>
          Any software development project team creating anything but the simplest, short-lived solutions knows the
          value of source code management (SCM). Without SCM, teams could not reliably recreate the source files that
          were used to build a specific release, making it impossible to reliably maintain what the team has delivered.
        </p>
        <p>
          However, a large development project involves much more shared information that just source files. Complex
          products and systems are mix of software, electronics, and hardware, with software taking an increasing role.
          Solution components are often developed by different organizations, using different method and tools, with
          lifecycle information stored in different repositories. The design and development of these complex systems
          requires many kinds of artifacts. Engineers in specialist disciplines produce these artifacts employing
          various engineering methods, disciplines and tools. Often these artifacts are not under Configuration
          Management, or if they are, it is done manually with half-measures that incur trade-offs. These challenges
          exist for software-only systems, yet their magnitude is much greater for products with physical, electrical
          and software aspects.
        </p>
        <p>
          For example, specific requirements are often associated with a particular release of components of a system.
          Analysis and design artifacts are created to understand how to address the impact of, or realize those
          requirements. Test cases and test results are used to validate that the work done on the systems actually
          meets the requirements.
        </p>
        <p>
          All this shared information is generally not available under the control of a single organization, set of
          tools or content management system, and it is often stored in repositories, not files in the file system. Like
          source files, all this shared information should be managed in a controllable, predictable way that is
          coordinated with specific solution releases.
        </p>
        <p>
          Development teams need an efficient, effective means of managing versions and variants of artifacts across the
          whole systems development lifecycle. They need to be able to capture, preserve, compare, merge and potentially
          recreate specific sets of versioned information covering the whole lifecycle in order to know who did what,
          when, and why.
        </p>
      </section>
      <section id="solution" class="level2">
        <h2>Solution</h2>
        <p>
          The OSLC Configuration Management specification defines an RDF vocabulary and a set of REST APIs for managing
          versions and configurations of linked data resources from multiple domains. Using client and server
          applications that implement the configuration management vocabulary and REST APIs allow a team administrator
          to create configurations of versioned resources contributed from tools and data sources across the lifecycle.
          These contributions can be assembled into aggregate (global) configurations that are used to resolve
          references to artifacts in a particular and reproducible context.
        </p>
        <p>
          Team members set the configuration context in each of the tools they use to refer to the particular global
          configuration that represents the state of the systems they are working on. They can create branches to
          support parallel development, and compare and merge branches to flow changes as needed. Product managers can
          create branches that represent different variants of a product in order to separate variation points and
          ensure changes are only applied to the appropriate variants.
        </p>
        <p>
          Development teams can create baselines that preserve the state of the federated, shared information in order
          to be able to recreate that state for any reason, including for regulatory compliance or for applying
          maintenance updates to released versions and/or variants of a product.
        </p>
      </section>
      <section id="business-value" class="level2">
        <h2>Business Value</h2>
        <p>
          The primary purpose for versioning and configuration management is to be able to establish and restore or
          recover a particular set of related resources in order to know and manage who changed what, when, and why.
          Applying these techniques to other disciplines, and combining them together, offers new opportunities for
          parallel development, managing change, reuse, and management of product variants in complex development
          projects.
        </p>
        <p>
          The benefits of source-code management are well known. However, achieving those benefits across all of the
          information that goes into designing, building, managing and governing the source code can be a challenge.
          This is because having multiple change and configuration management solutions for different artifact types
          requires manual coordination of versions and variants across the tools. The OSLC Configuration Management
          specification specifies a standard way in which different tools, developed by different suppliers, at
          different times, using different repositories and data representations can contribute version and
          configuration information across the whole lifecycle.
        </p>
        <p>The resulting business value includes:</p>
        <ul>
          <li>Cross-tool version and configuration management related shared information</li>
          <li>Support for context-specific link navigation and management</li>
          <li>Automatic configuration management of complex solutions and systems</li>
          <li>
            Enable parallel, independent, development streams with branching and merging of all lifecycle information
          </li>
          <li>
            Save and restore consistent sets of related information for any purpose including regulatory compliance and
            product maintenance releases
          </li>
          <li>Manage different variants of a related set of deliverables, solutions and/or products</li>
          <li>Reuse utilizing commonality/variability for Product Line Engineering (PLE)</li>
        </ul>
        <p>Some typical uses of versioning and configuration management capabilities include:</p>
        <ul>
          <li>
            Creating baselines of development streams in order to capture and preserve the state of a system at
            different points in time
          </li>
          <li>
            Use release stabilization streams to complete development of specific releases while allowing ongoing future
            development to continue in parallel Branching streams for different purposes including experimentation, A/B
            testing, gradual production rollout, importing from a supplier, etc., and delivering changes on streams to a
            common shared stream in a controlled manner.
          </li>
          <li>
            Parallel development on shared artifacts, overlapping releases or the common parts of product variants with
            the ability to compare different streams and flow changes as needed to meet requirements, enforce enterprise
            asset management and governance, and promote reuse.
          </li>
          <li>
            Create maintenance branches and control propagation of maintenance changes into ongoing development streams
            in a controlled, predictable manner
          </li>
          <li>Managing configurations of related, federated, shared information across the whole lifecycle.</li>
          <li>
            Isolate changes for different variants on different streams while also managing common, reusable components.
          </li>
          <li>
            Enable reuse of lifecycle artifacts including requirements and test cases, as well as the relationships
            between them, including regulatory and security requirements and test cases.
          </li>
          <li>
            Enable analysts and designers to work one iteration ahead in agile projects in order to better inform
            iteration planning and development.
          </li>
          <li>
            Enable progressive contribution of parts of a large system with baselines that capture each significant
            evolution of the system.
          </li>
          <li>
            Support different approaches to reuse by branching from product streams that are closes to the new variant,
            or branching from a common base that is maintained as a reusable enterprise asset.
          </li>
          <li>
            Enable concurrent development of shared enterprise assets in different product delivery streams
            (requirements delivery life-cycles) while at the same time managing and governing changes to long-lived
            enterprise assets (asset management life-cycles).
          </li>
        </ul>
      </section>
    </section>
    <section id="concepts" class="level1">
      <h1>Concepts</h1>
      <p>
        <a href="https://en.wikipedia.org/wiki/Configuration_management">Configuration Management on Wikipedia</a>
        defines Configuration Management as follows:
      </p>
      <blockquote>
        <p>
          Configuration management (CM) is a systems engineering process for establishing and maintaining consistency of
          a product’s performance, functional, and physical attributes with its requirements, design, and operational
          information throughout its life.
        </p>
      </blockquote>
      <p>
        In Configuration Management, artifacts are versioned. For example, a new requirement R1 might be defined and
        created. Once the content of that requirement is checked in or committed, version 1 of that requirement R1
        exists. At that point, the contents of version 1 cannot be changed. If changes are required, the content is
        changed, and when checked in or delivered, results in version 2 of requirement R1. Version 2 of R1 was created
        from, or derived from, version 1 of R1. The sequence of versions of that requirement comprise its
        <em>version history</em>. In OSLC Configuration Management, the term <em>concept resource</em> is used to mean
        all the versions of some artifact. In our example, requirement R1 is a concept resource (no version is
        specified), and requirement R1 version 1 is a specific version of that concept resource. Many versioning systems
        exist, and there are a number of different approaches as to how artifacts are versioned, when those versions are
        created, and when a version becomes non-modifiable. However, all versioning systems support some notion of when
        a change is committed, the version that records that change becomes non-modifiable. The OSLC Configuration
        Management specification does not define how versioning should be implemented. For example, some versioning
        systems assign <em>version identifiers</em> separately for each versioned resource, while other versioning
        system version an entire repository so that a version identifier is “global” across all versioned resources.
        Servers are free to choose existing versioning systems, or implement a versioning system of their own design.
      </p>
      <p>
        An important element of Configuration Management is a <em>configuration</em>. A configuration defines what set
        of version resources are used in that configuration. For example, configuration C1 might use version 1 of
        requirement R1, and configuration C2 might use version 2 of requirement R1. New artifacts might be added to or
        obsolete artifacts removed from a configuration. The configuration therefore provides a view of the appropriate
        artifacts and versions of those artifacts that apply in that configuration. The OSLC Configuration Management
        specification defines this in terms of <em>selections</em>. A configuration might reference a
        <em>selections</em> resource that in turn references the specific version resources that belong in that
        configuration.
      </p>
      <p>
        In OSLC Configuration Management, a <em>stream</em> is a modifiable configuration in which artifacts may be
        added or removed, or a different version of an artifact may be selected by a user to replace some other version
        of that artifact. Streams are the configurations in which ongoing work is performed. An essential element of
        Configuration Management is the ability to create a non-modifiable record of the set of version resources at
        specific milestones or points in time in order to provide traceability and auditing. In OSLC Configuration
        Management, a <em>baseline</em> is a non-modifiable configuration whose set of version resources are also
        non-modifiable. Usually a baseline is created from a stream, recording the state of that stream. The stream
        continues to be modifiable, but the baseline is now a non-modifiable record of the state of the stream at the
        time the baseline was created. Every configuration is associated with a <em>component</em>. A
        <em>component</em> is a unit of organization consisting of a set of version resources. When a
        <em>baseline</em> is created from a <em>stream</em>, both the baseline and the stream are for the same
        <em>component</em>. The granularity of a component is up to an application designer.
      </p>
      <p>
        OSLC Configuration Management supports the idea that a configuration may be a container of other configurations.
        The term <em>contribution</em> describes a resource that has both a <em>contribution order</em> property and a
        reference to a configuration that is used by a parent configuration. Strictly speaking, the term
        <em>contribution</em> means a contribution resource, but is sometimes used informally as a shorthand for child
        configuration which is a <em>contributed configuration</em>. Configurations may thus form a
        <em>hierarchy</em> of configurations. The term <em>global configuration</em> is used to describe a configuration
        that aggregates configurations, especially those from other configuration management servers. For example, a
        global configuration might have contributions from a requirements management server, a quality management
        server, and a source code control server. The global configuration thus represents the state of version
        resources across those application servers.
      </p>
      <p>
        There is a UML class diagram in section 7 that describes how these concepts, and those in following sections,
        relate to the resources described in the OSLC Configuration Management Specification.
      </p>
    </section>
    <section id="representation-of-version-resources" class="level1">
      <h1>Representation of version resources</h1>
      <p>
        We will use an example of two requirements, A and B, in order to explain some of the concepts and
        representations. From a concept resource point of view, one might think of the requirements as having some basic
        properties as shown below. Requirement B <em>refines</em> requirement A.
      </p>
      <pre><code>Requirement_a
    id: a
    name: &quot;Requirement A&quot;
    description: &quot;A description of requirement A&quot;


    Requirement_b
    id: b
    name: &quot;Requirement B&quot;
    description: &quot;A description of requirement B&quot;
    refines: Requirement_a</code></pre>
      <p>
        Let’s look at a possible RDF representation of requirement A version 1 (<code>requirementA-v1</code>). The RDF
        graph of <code>requirementA-v1</code> might look something like:
      </p>
      <pre><code>:requirementA-v1
        a oslc_config:VersionResource ;
        dcterms:isVersionOf :requirementA .
    :requirementA
        a oslc_rm:Requirement ;
        oslc_config:versionId &quot;v1&quot; ;
        oslc_config:component :rmComponent1 ;
        dcterms:identifier &quot;A&quot; ;
        dcterms:title &quot;Requirement A&quot;^^rdf:XMLLiteral ;
        dcterms:description &quot;A description of requirement A version 1&quot;^^rdf:XMLLiteral .</code></pre>
      <p>There are two important things to note:</p>
      <ol type="1">
        <li>
          The main properties of the requirement are made using a subject URI of the <em>concept resource</em>
          <code>:requirementA</code> and <strong>not</strong> the URI of the specific version
          <code>:requirementA-v1</code>. This is done so that the same subject is used for properties of all the
          versions of that concept resource. A query against the concept URI <code>:requirementA</code> and
          <code>dcterms:description</code> would give the descriptions of requirement A across all versions.
        </li>
        <li>
          There are a few statements made using the subject URI of the version resource
          <code>:requirementA-v1</code> that specify the artifact is a version resource and its concept resource.
        </li>
      </ol>
      <p>
        Now consider that requirement A has been updated with a new description, resulting in version 2
        (<code>requirementA-v2</code>):
      </p>
      <pre><code>:requirementA-v2
        a oslc_config:VersionResource ;
        dcterms:isVersionOf :requirementA ;
        prov:wasRevisionOf :requirementA-v1 .
    :requirementA
        a oslc_rm:Requirement ;
        oslc_config:versionId &quot;v2&quot; ;
        oslc_config:component :rmComponent1 ;
        dcterms:identifier &quot;A&quot; ;
        dcterms:title &quot;Requirement A&quot;^^rdf:XMLLiteral ;
        dcterms:description &quot;A description of requirement A version 2 (changed description)&quot;^^rdf:XMLLiteral .</code></pre>
      <p>
        The statements using subject URI <code>:requirementA-v2</code> include
        <code>prov:wasRevisionOf :requirement-v1</code>, indicating that version 2 was derived from or created from
        version 1 of requirement A. The <code>dcterms:description</code> of the concept resource specifies the changed
        description for version 2.
      </p>
      <p>Similarly, one might have requirement B version 1 (<code>requirementB-v1</code>):</p>
      <pre><code>:requirementB-v1
        a oslc_config:VersionResource .
        dcterms:isVersionOf :requirementB .
    :requirementB
        a oslc_rm:Requirement ;
        oslc_config:versionId &quot;v1&quot; ;
        oslc_config:component :rmComponent1 ;
        dcterms:identifier &quot;B&quot; ;
        dcterms:title &quot;Requirement B&quot;^^rdf:XMLLiteral ;
        dcterms:description &quot;A description of requirement B version 1&quot;^^rdf:XMLLiteral ;
        oslc_rm:refines :requirementA.</code></pre>
      <p>
        Note that the <code>oslc_rm:refines</code> link is to the <em>concept resource</em> of requirement A
        <code>:requirementA</code> and <strong>not</strong> to a version of that requirement. While an implementation
        <em>could</em> link to a specific version resource, that’s usually undesirable. Consider what would happen if
        <code>requirementB-v1</code> referenced <code>requirementA-v1</code>. When version 2 of requirement A is
        created, one might want requirement B to reference it. This would require that a new version 2 of requirement B
        be created in order to update that link. This results in a lot of new versions because the links themselves are
        referencing specific versions. If the link references the concept resource, the <em>resolution</em> of which
        version of requirement A is referenced, is decoupled and deferred. A user that views requirements A and B in a
        particular <em>configuration context</em> will see the versions of both requirements <em>resolved</em> in that
        configuration context. If requirement A was updated to version 2 in that context, then
        <code>requirementB-v1</code> will have a <em>refines</em> link that now <em>resolves</em> to
        <code>requirementA-v2</code>. This avoids the need to update requirement B to reference that new version of
        requirement A.
      </p>
      <p>
        Typically applications provide some means for a user to select their <em>configuration context</em> in their
        user interface. For work in progress, this is usually a stream. If the user wants to see the versions of
        artifacts that were used at an important milestone, they would typically select the baseline that was created
        for that milestone. From a REST API standpoint, a configuration context can be specified using either a
        <code>Configuration-Context</code> header or a <code>oslc_config.context</code> parameter in the request.
      </p>
    </section>
    <section id="local-configurations" class="level1">
      <h1>Local configurations</h1>
      <p>
        A configuration created in and used by an application to manage the selected versions in that configuration is
        called a <em>local configuration</em>. Using the previous example based on requirements, let’s imagine we have a
        stream in a requirements management application that selects requirements <code>requirementA-v1</code> and
        <code>requirementB-v1</code>. The RDF representation of that stream might be as follows:
      </p>
      <pre><code>:rmStream1
        a oslc_config:Stream ;
        dcterms:title &quot;First requirements management stream&quot;^^rdf:XMLLiteral ;
        oslc_config:component :rmComponent1 ;
        oslc_config:selections :rmStream1Selections ;
        oslc_config:acceptedBy oslc_config:Configuration .</code></pre>
      <p>
        A configuration always has a component. The stream references zero, one, or more <em>selections</em> resource(s)
        that specify what version resources are selected by the stream. In our example, the selections resource might be
        as follows:
      </p>
      <pre><code>:rmStream1Selections
        oslc_config:selects :requirementA-v1, :requirementB-v1 .</code></pre>
      <p>
        A user might want to capture the state of that stream by creating a <em>baseline</em>. The RDF representation of
        such a baseline might be as follows:
      </p>
      <pre><code>:rmBaseline1
        a oslc_config:Baseline;
        dcterms:title &quot;First requirements management stream (first baseline)&quot;^^rdf:XMLLiteral ;
        oslc_config:component :rmComponent1 ;
        oslc_config:selections :rmBaseline1Selections ;
        oslc_config:baselineOfStream :rmStream1 ;
        oslc_config:acceptedBy oslc_config:Configuration .</code></pre>
      <p>
        The <code>oslc_config:baselineOfStream</code> property specifies the stream that the baseline was created from.
        The selections resource referenced by that baseline might be as follows:
      </p>
      <pre><code>:rmBaseline1Selections
        oslc_config:selects :requirementA-v1, :requirementB-v1 .</code></pre>
      <p>
        Creating that baseline from the stream results in that stream’s representation including an [updated]
        <code>oslc_config:previousBaseline</code> property:
      </p>
      <pre><code>:rmStream1
        a oslc_config:Stream ;
        dcterms:title &quot;First requirements management stream&quot;^^rdf:XMLLiteral ;
        oslc_config:component :rmComponent1 ;
        oslc_config:selections :rmStream1Selections ;
        oslc_config:acceptedBy oslc_config:Configuration ;
        oslc_config:previousBaseline :rmBaseline1 .</code></pre>
      <p>
        When requirement A was changed to create version 2, the stream <code>rmStream1</code> would be updated to select
        that version:
      </p>
      <pre><code>:rmStream1Selections
        oslc_config:selects :requirementA-v2, :requirementB-v1 .</code></pre>
      <p>
        The baseline <code>rmBaseline1</code> continues to select <code>:requirementA-v1</code> and
        <code>:requirementB-v1</code>. The selections of a baseline cannot be modified. The baseline therefore serves as
        a non-modifiable record of the state of the stream from which it was created at a specific point in time.
      </p>
    </section>
    <section id="global-configurations" class="level1">
      <h1>Global configurations</h1>
      <p>
        A <em>global configuration</em> is a configuration used to assemble other configurations (typically from other
        application servers) into a hierarchy. To understand the usage, let’s consider that we have a quality management
        application that has a test case <code>testCaseA</code> that validates <code>requirementA</code>. Version 1 of
        that test case might have an RDF representation as follows:
      </p>
      <pre><code>:testCaseA-v1
        a oslc_config:VersionResource ;
        dcterms:isVersionOf :testCaseA ;
    :testCaseA
        a oslc_qm:TestCase ;
        dcterms:title &quot;Test case validating requirement A&quot;^^rdf:XMLLiteral ;
        dcterms:description &quot;Details of how the test case validates requirement A&quot;^^rdf:XMLLiteral ;
        oslc_qm:validatesRequirement :requirementA .</code></pre>
      <p>
        In this example, the quality management application has its own local stream that selects
        <code>testcaseA-v1</code>:
      </p>
      <pre><code>:qmStream1
        a oslc_config:Stream ;
        dcterms:title &quot;First quality management stream&quot;^^rdf:XMLLiteral ;
        oslc_config:component :qmComponent1 ;
        oslc_config:selections :qmStream1Selections ;
        oslc_config:acceptedBy oslc_config:Configuration .</code></pre>
      <p>with its referenced selections resource:</p>
      <pre><code>:qmStream1Selections
        oslc_config:selects :testCaseA-v1 .</code></pre>
      <p>
        A user looking at test cases in the context of configuration <code>qmStream1</code> would see
        <code>testCaseA-v1</code>. That test case has a <em>validates requirement</em> link to requirement A. However,
        in that configuration context, it is not possible to <em>resolve</em> the link to a version of the requirement
        concept resource because that is managed by the requirement management application and not the quality
        management application.
      </p>
      <p>
        This is where a <em>global configuration</em> is useful. As an example, say we have a global stream that has
        <em>contributions</em> from <code>rmStream1</code> and <code>qmStream1</code>. Its RDF representation might be
        as follows:
      </p>
      <pre><code>:globalStream1
        a oslc_config:Stream ;
        dcterms:title &quot;First global stream&quot;^^rdf:XMLLiteral ;
        oslc_config:accepts oslc_config:Configuration ;
        oslc_config:acceptedBy oslc_config:Configuration ;
        oslc_config:contribution :contribution1, :contribution2 .
    :contribution1:
        oslc_config:configuration :rmStream1 ;
        oslc_config:contributionOrder &quot;1&quot; .
    :contribution2:
        oslc_config:configuration :qmStream1 ;
        oslc_config:contributionOrder &quot;2&quot; .</code></pre>
      <p>
        A user is working in the configuration context <code>globalStream1</code>. In the requirements management
        application, when the user looks at the requirements for component <code>rmComponent1</code>, they see
        <code>requirementA-v2</code> and <code>requirementB-v1</code>. The requirements management application resolves
        the component <code>rmComponent1</code> in the context of global configuration <code>globalStream1</code>. The
        global configuration has only one contribution associated with <code>rmComponent1</code> and that’s for the
        local configuration <code>rmStream1</code>. That local configuration selects <code>requirementA-v2</code> and
        <code>requirementB-v1</code>. Similarly, in the quality management application, when the user looks at the test
        cases for component <code>qmComponent1</code>, they see <code>testCaseA-v1</code>.
      </p>
      <p>
        For that test case, the quality management user sees the <em>validates requirement</em> link to
        <code>requirementA-v2</code>. The quality management application only knows the link is to the test case concept
        resource <code>requirementA</code> and cannot resolve which version of that requirement is referenced. This is
        because the requirements management application that owns that requirement manages the configurations that
        select it. So how does the quality management application resolve the link to the requirement to a specific
        version?
      </p>
      <p>
        When referencing that requirement, it uses a <code>oslc_config.context</code> query parameter or a
        <code>Configuration-Context</code> header with a value that is the URI of the configuration context. For example
        <code>":requirementA?oslc_config.context=':globalStream1'"</code>. The parameter value is shown here without URL
        encoding for clarity. In practice, parameter values should be URL encoded. When the requirements management
        application gets a request to fetch that requirement, it resolves the concept resource URI in the specified
        configuration context. In this example, it knows that the requirement concept resource
        <code>requirementA</code> is owned by component <code>rmComponent1</code>, and resolves that component in the
        global configuration context <code>globalStream1</code> to the local configuration <code>rmStream1</code>, and
        then resolves the requirement concept resource <code>requirementA</code> to <code>:requirementA-v2</code>.
      </p>
      <p>How does an application resolve a component in a global configuration context to a local configuration?</p>
      <p>
        Say an RM application wants to resolve component <code>rmComponent1</code> in the context of
        <code>globalStream1</code>. The starting point is to consider the hierarchy of the global configuration
        <code>:globalStream1</code> and associated components. The previous example yields the tree shown below:
      </p>
      <pre><code>    globalStream1 (component=globalComponent1)
            rmStream1 (component=rmComponent1, order=1)
            qmStream1 (component=qmComponent1, order=2)</code></pre>
      <p>
        An application traverses this tree looking for component <code>rmComponent1</code> and finds
        <code>rmStream1</code>. When the tree only contains a single configuration for a particular component, the order
        of traversal does not matter.
      </p>
      <p>
        In practice, constructing a contribution tree by fetching data each time a component needs to be resolved to a
        local configuration does not scale well or provide the performance required for frequent resolution.
        Implementations commonly use some form of caching of that data and use an implementation dependent way of
        maintaining that cached data.
      </p>
      <p>Global configurations therefore fulfill two important functions:</p>
      <ul>
        <li>
          They allow a configuration context to be used across applications that allow an application to resolve their
          concept resources to the right versions.
        </li>
        <li>
          They allow links between concept resources in <em>different</em> applications to be viewed and navigated to
          the right versions of those artifacts in that configuration context.
        </li>
      </ul>
      <p>
        The distinction between a local configuration and a global configuration is a fuzzy one. Consider a requirements
        management server that supports configurations that have contributions from other configurations in the same
        server but not other servers. Should such a configuration be called a local configuration or a global
        configuration? The distinguishing characteristics of a global configuration are that they are normally usable as
        contributions in any other global configuration and may use contributions from any local or global
        configuration. So such a configuration would be more accurately termed a local configuration even though it has
        contributions.
      </p>
    </section>
    <section id="uml-class-diagram" class="level1">
      <h1>UML Class diagram</h1>
      <p>
        The UML class diagram below shows the main elements of the configuration management specification. It
        intentionally omits some relationships for the sake of clarity. The resource shapes in the specification remain
        the definitive reference.
        <img src="https://lucid.app/publicSegments/view/d6da1584-ba23-4b93-a2a9-c0f8aca038b9/image.png" />
      </p>
      <p>Some key aspects of the representation are:</p>
      <ul>
        <li>
          The version resources selected by a configuration are determined using the property path
          <code>oslc_config:selections/oslc_config:selects</code>.
        </li>
        <li>
          The immediate contributed configurations to a configuration are determined using the property path
          <code>oslc_config:contribution/oslc_config:configuration</code>. Contribution resources are embedded within
          configurations.
        </li>
        <li>Global configurations often only have contributions and not selections.</li>
        <li>Local configurations often only have selections and not contributions.</li>
      </ul>
    </section>
    <section id="component-skew-and-contribution-order" class="level1">
      <h1>Component skew and contribution order</h1>
      <p>
        Consider a global stream <code>globalStream2</code> that has contributions from <code>rmStream1</code>,
        <code>rmBaseline1</code>, and <code>:qmStream1</code> in that order. <code>rmStream1</code> and
        <code>rmBaseline1</code> are for the same <em>component</em>. Where a configuration hierarchy has contributions
        from two <em>different</em> configurations of the same component, this is called <em>component skew</em>.
      </p>
      <p>Now consider the contribution tree for <code>globalStream2</code>:</p>
      <pre><code>    globalStream2 (component=globalComponent1)
            rmStream1 (component=rmComponent1, order=1)
            rmBaseline1 (component=rmComponent1, order=2)
            qmStream1 (component=qmComponent1, order=3)</code></pre>
      <p>
        When resolving the concept <code>requirementA</code> in the context of <code>globalStream2</code>, should this
        resolve to <code>requirementA-v2</code> selected by <code>rmStream1</code> or
        <code>requirementA-v1</code> selected by <code>rmBaseline1</code>? The component skew is resolved by the order
        in which the contribution tree is traversed. If the traversal algorithm orders <code>rmStream1</code> before
        <code>rmBaseline1</code>, then component <code>rmComponent1</code> resolves to <code>rmStream1</code>, and the
        <code>requirementA</code> resolves to <code>requirementA-v2</code>.
      </p>
      <p>
        The configuration management specification does not prescribe a traversal algorithm, but a common approach is to
        perform a depth-first, sibling ordered by contribution order second traversal. Consider the following
        configuration hierarchy:
      </p>
      <pre><code>    globalStream2 (component=globalComponent1)
            globalStream3 (component=globalComponent2, order=1)
                rmStream1 (component=rmComponent1, order=1)
            globalStream4 (component=globalComponent3, order=2)
                rmBaseline1 (component=rmComponent1, order=1)
                qmStream1 (component=qmComponent1, order=2)</code></pre>
      <p>
        A depth-first, sibling ordered by contribution order second traversal results in the following traversal order:
      </p>
      <pre><code>    globalStream2
        globalStream3
        rmStream1
        globalStream4
        rmBaseline1
        qmStream1</code></pre>
      <p>
        Note that the contribution order should be sorted as an ASCII string rather than being treated as a numeric
        string.
      </p>
    </section>
    <section id="branching" class="level1">
      <h1>Branching</h1>
      <p>
        The OSLC Configuration Management specification does not define whether a versioning system should support
        branching and/or parallel versions, and if so how these are managed. Some versioning systems support branches as
        first-class objects, and there are actions to create branches. Some versioning system handling branching by
        copying data into different paths in the repository, referencing the shared artifacts. Other versioning systems
        regard branching as simply parallel versions, perhaps for different variants or purposes. Because of these
        different approaches, branching is not covered by the specification so that it remains implementable across a
        wider range of systems.
      </p>
      <p>
        From an OSLC standpoint, clients create new versions of concept resources by a PUT on the concept URI with a
        configuration context specifying the stream that will be updated to use the new version. The version that was
        previously used in that stream is the predecessor version of the newly created version. For example, if
        <code>:rmStream1</code> uses <code>requirementA-v1</code>, a new version <code>requirementA-v2</code> might be
        created from it by a <code>PUT requirementA?oslc_config.context=%3ArmStream1</code>. If a client then requests a
        new version be created from <code>requirementA-v1</code> in some other stream, an implementation that supports
        branching might create <code>requirementA-v2.1</code> as a parallel version to <code>requirementA-v2</code>. An
        implementation that only supports linear versioning might fail the request.
      </p>
      <p>
        Typically, parallel development for different branches or purposes is performed in separate <em>streams</em>.
        For example, parallel streams might be created from the same baseline in order to work on separate features for
        some release. The OSLC Configuration Management specification does not define any mechanisms for merging
        streams. However, a client can PUT merged content to the concept resource where the merged content has multiple
        <code>prov:wasRevisionOf</code> statements indicating the contents were merged from those predecessor versions.
      </p>
    </section>
    <section id="implementation-elements" class="level1">
      <h1>Implementation elements</h1>
      <section id="introduction" class="level2">
        <h2>Introduction</h2>
        <p>
          When adding support for OSLC Configuration Management to an application, or writing an adapter to provide such
          support to an existing application, there are a number of elements to the implementation. To gain the full
          power of configuration management, an implementation should support both version resources and configurations.
          An implementation need not follow the ordering of the following sections. However, the ordering reflects some
          of the dependencies that an implementation is likely to face. For example, versioned artifacts belong to a
          component, so support for components might be better implemented before versioned artifacts. Within each
          section, a minimal set of elements is described, followed by optional elements. An implementation might want
          to tackle the minimal elements first, then revisit each of the sections and consider tackling some or all of
          the optional elements.
        </p>
        <p>
          Some applications support a notion of a <em>project</em> or <em>project area</em> that serve as a container of
          resources and for managing access to those resource in that container. While this notion is not part of any
          OSLC specification, it is mentioned here because it may affect the implementation. Applications that support
          this or similar containers, might want to declare a separate <code>oslc:ServiceProvider</code> for each such
          container. For example, this is a common convention for IBM Jazz applications.
        </p>
      </section>
      <section id="components" class="level2">
        <h2>Components</h2>
        <section id="minimal-elements" class="level3">
          <h3>Minimal elements</h3>
          <p>At a minimum, an implementation should provide REST support for:</p>
          <ul>
            <li>
              <code>GET</code> of a component URI. The RDF of a component should include a
              <code>oslc_config:configurations</code> statement to a <em>Linked Data Platform Container</em> (LDPC). The
              response should include an <code>Etag</code> header whose value represents the state of the component.
            </li>
            <li>
              <code>PUT</code> of a component. The implementation should require the use of an ‘If-match’ header whose
              value matches the current Etag.
            </li>
            <li>
              <code>GET</code> of a component’s configurations LDPC, returning a container that references all the
              configurations of that container.
            </li>
          </ul>
          <p>
            While it is valid to create a component that initially does not have any configurations, it is good practice
            when creating a component to do either of:
          </p>
          <ul>
            <li>Create an empty initial baseline, then create an empty default stream from that baseline.</li>
            <li>Create an empty default stream.</li>
          </ul>
        </section>
        <section id="optional-elements" class="level3">
          <h3>Optional elements</h3>
          <ul>
            <li>
              Support resource shapes for components. Each component should include in its RDF representation an
              <code>oslc:instanceShape</code> property that references a resource shape for that component.
            </li>
            <li>
              Support an OSLC selection dialog of components. This should be declared in an
              <code>oslc:Service</code> that is discoverable from a <code>oslc:ServiceProviderCatalog</code>.
            </li>
            <li>
              Support for an <code>oslc:CreationFactory</code> for components. This should be declared in an
              <code>oslc:Service</code> that is discoverable from a <code>oslc:ServiceProviderCatalog</code>. The
              creation factory should reference a resource shape for components.
            </li>
            <li>
              Support <code>POST</code> on a component’s configurations LDPC as a means of creating a new stream for
              that component.
            </li>
            <li>
              Support OSLC query on components. An <code>oslc:QueryCapability</code> should be declared in an
              <code>oslc:Service</code> that is discoverable from a <code>oslc:ServiceProviderCatalog</code>. The query
              capability should reference a resource shape for the query container, and that resource shape should
              reference a value shape for the components that might be returned in that container.
            </li>
          </ul>
        </section>
      </section>
      <section id="configurations" class="level2">
        <h2>Configurations</h2>
        <section id="minimal-elements-1" class="level3">
          <h3>Minimal elements</h3>
          <p>At a minimum, an implementation should provide REST support for:</p>
          <ul>
            <li>
              <code>GET</code> on a configuration URI. If the application manages versioned resources, the RDF
              representation should include a <code>oslc_config:selections</code> statement to a selections resource.
              The response should include an <code>Etag</code> header whose value represents the state of that stream.
            </li>
            <li>
              <code>PUT</code> of a configuration. The implementation should require the use of an ‘If-match’ header
              whose value matches the current Etag.
            </li>
            <li>
              <code>GET</code> on a selections resource (if the application manages versioned resources). The RDF
              representation should include a <code>oslc_config:select</code> statement to each version resource URI
              selected by that configuration.
            </li>
          </ul>
        </section>
        <section id="optional-elements-1" class="level3">
          <h3>Optional elements</h3>
          <ul>
            <li>
              Support resource shapes for configurations. Each configuration should include in its RDF representation an
              <code>oslc:instanceShape</code> property that references a resource shape for that configuration.
            </li>
            <li>
              Support <code>oslc_config:streams</code> property in the RDF of a baseline, and support a
              <code>GET</code> on that LDPC. Optionally support <code>POST</code> on that LDPC as a means of creating a
              stream from the baseline.
            </li>
            <li>
              Support <code>oslc_config:baselines</code> property in the RDF of a stream, and support a
              <code>GET</code> on that LDPC. Optionally support <code>POST</code> on that LDPC as a means of creating a
              baseline from the stream.
            </li>
            <li>
              Support an OSLC selection dialog of configurations. This should be declared in an
              <code>oslc:Service</code> that is discoverable from a <code>oslc:ServiceProviderCatalog</code> and its
              referenced <code>oslc:serviceProvider</code> members.
            </li>
            <li>
              Support for an <code>oslc:CreationFactory</code> for configurations. This should be declared in an
              <code>oslc:Service</code> that is discoverable from a <code>oslc:ServiceProviderCatalog</code> and its
              referenced <code>oslc:serviceProvider</code> members. The creation factory should reference a resource
              shape for configurations.
            </li>
            <li>
              Support OSLC query on configurations. An <code>oslc:QueryCapability</code> should be declared in an
              <code>oslc:Service</code> that is discoverable from a <code>oslc:ServiceProviderCatalog</code> and its
              referenced <code>oslc:serviceProvider</code> members. The query capability should reference a resource
              shape for the query container, and that resource shape should reference a value shape for the
              configurations that might be returned in that container.
            </li>
            <li>Support <code>DELETE</code> of a local configuration.</li>
          </ul>
        </section>
      </section>
    </section>
    <section id="concept-resources-and-version-resources" class="level1">
      <h1>Concept resources and version resources</h1>
      <section id="minimal-elements-2" class="level2">
        <h2>Minimal elements</h2>
        <p>At a minimum, an implementation should provide REST support for:</p>
        <ul>
          <li>
            <code>GET</code> on a version resource URI. The RDF representation of the version resource should:
            <ul>
              <li>
                Include statements against the version URI declaring it of type
                <code>oslc_config:versionResource</code>, and <code>dcterms:isVersionOf</code> referencing the concept
                resource URI.
              </li>
              <li>
                Include statements about the properties of the resource using the concept resource URI as the subject.
              </li>
            </ul>
          </li>
          <li>
            <code>GET</code> on a concept resource with a local configuration context specified by a
            <code>oslc_config.context</code> query parameter or header. This should resolve the concept resource to the
            version resource and return the RDF of that version resource. This requires that the application be able to
            determine the component to which a specified concept resource belongs.
          </li>
        </ul>
      </section>
      <section id="optional-elements-2" class="level2">
        <h2>Optional elements</h2>
        <ul>
          <li>
            Support <code>GET</code> on a concept resource with a global configuration context specified by a
            <code>oslc_config.context</code> query parameter or header. This should resolve the concept resource in the
            context of that global configuration to the version resource and return the RDF of that version resource.
            This is required if the application is to be used with global configurations. The only mechanism for
            resolving a local component to a local configuration in a global configuration context covered by the
            specification is for an application to <code>GET</code> the global configuration to discover its
            contributions, and then repeat this recursively on the contributions to discover the contribution hierarchy.
            Doing this each time resolution is required is likely to be expensive. Implementations should consider
            whether some form of local caching of contribution trees is required to meet performance goals of the
            application.
          </li>
          <li>
            Support <code>GET</code> on a concept resource without a configuration context specified by a
            <code>oslc_config.context</code> query parameter or header. The application should determine a
            <em>default configuration</em>, and then use that as the configuration to resolve the concept resource.
            should resolve the concept resource in the context of that global configuration to the version resource and
            return the RDF of that version resource. This is required if the application is to be used with global
            configurations.
          </li>
          <li>
            Support <code>POST</code> to a component with a <code>oslc_config.context</code> query parameter or
            <code>Configuration-Context</code> header to create a new concept resource.
          </li>
          <li>
            Support <code>PUT</code> to a concept resource with a <code>oslc_config.context</code> query parameter or
            <code>Configuration-Context</code> header specifying a stream in which to create a new version from a
            currently used version.
          </li>
          <li>
            Support <code>DELETE</code> of a version resource with a <code>oslc_config.context</code> query parameter or
            header to delete the current mutable version resource from a specified stream.
          </li>
          <li>
            Support an <code>oslc:CreationFactory</code> that can create new concept resources and their initial version
            in the context of a configuration.
          </li>
        </ul>
      </section>
    </section>
    <section id="references" class="level1">
      <h1>References</h1>
      <p>
        <a href="https://oslc-op.github.io/oslc-specs/specs/config/oslc-config-mgt.html"
          >https://oslc-op.github.io/oslc-specs/specs/config/oslc-config-mgt.html</a
        >
      </p>
    </section>
  </body>
</html>

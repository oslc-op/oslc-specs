<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Configuration Management 1.0 Primer</title>
    <meta charset="utf-8" />
    <meta name="description" content="This primer serves as a guide to the concepts in the specification, and through the use of simple examples, explains how versioning and configurations are represented, how and when local configurations and global configurations are used, and lists the elements that an implementation should consider." />

    <!-- <script
      src="https://cdn.jsdelivr.net/gh/oasis-tcs/tab-respec@v2.1.30/builds/respec-oasis-common.min.js"
      async
      class="remove"
    ></script> -->
    <script src="http://127.0.0.1:9000/respec-oasis-common.js" async class="remove"></script>
    <script class="remove">
      var respecConfig = {
        shortName: "config-primer",
        specStatus: "PN",
        revision: "01",
        publishDate: "2021-11-04T18:00Z",

        edDraftURI: "https://oslc-op.github.io/oslc-specs/notes/config-primer/config-primer.html",
        thisVersion: "https://docs.oasis-open-projects.org/oslc-op/notes/config-primer/pn01/config-primer.html",
        // prevVersion: null,
        // latestVersion: "https://oslc-op.github.io/oslc-specs/notes/config-primer/config-primer.html",
        // latestSpecVersion: "https://oslc-op.github.io/oslc-specs/notes/config-primer/config-primer.html",

        // Other parts of multi-part spec
        additionalArtifacts: [],

        relatedWork: [],

        localBiblio: {
          OSLCCore3: {
            title: "OSLC Core 3.0",
            href: "https://docs.oasis-open.org/oslc-core/oslc-core/v3.0/csprd03/part1-overview/oslc-core-v3.0-csprd03-part1-overview.html",
            authors: ["Jim Amsden", "S. Speicher"],
            status: "Committee Specification Public Review Draft",
            publisher: "OASIS",
          },
          OSLCCoreVocab: {
            title: "OSLC Core Vocabulary",
            href: "https://docs.oasis-open.org/oslc-core/oslc-core/v3.0/csprd03/part7-core-vocabulary/oslc-core-v3.0-csprd03-part7-core-vocabulary.html",
            authors: ["Jim Amsden", "S. Padgett", "S. Speicher"],
            status: "Committee Specification Public Review Draft",
            publisher: "OASIS",
          },
          OSLCShapes: {
            title: "OSLC Resource Shape 3.0",
            href: "https://docs.oasis-open.org/oslc-core/oslc-core/v3.0/csprd03/part6-resource-shape/oslc-core-v3.0-csprd03-part6-resource-shape.html",
            authors: ["Arthur Ryman", "Jim Amsden"],
            status: "Committee Specification Public Review Draft",
            publisher: "OASIS",
          },
        },

        license: "cc-by-4",
        additionalLicenses: [
          {
            licenseName: "Apache License 2.0",
            licenseURI: "https://www.apache.org/licenses/LICENSE-2.0",
          },
        ],
        citationLabel: "OSLC-CCM-30-Primer",
        maxTocLevel: 3,
        conformanceLabelPrefix: "QM",
        // noConformanceStyling: 1,
        // noConformanceTable: 1,
        // conformanceClauseStrength : 1,
        editors: [],

        // name of the OP
        wg: "OASIS Open Services for Lifecycle Collaboration (OSLC) OP",
        wgShortName: "oslc-op",
        chairs: [
          {
            name: "Jim Amsden",
            mailto: "jamsden@us.ibm.com",
            company: "IBM",
            companyURL: "https://www.ibm.com/",
          },
          {
            name: "Andrii Berezovskyi",
            mailto: "andriib@kth.se",
            company: "KTH",
            companyURL: "https://www.kth.se/en",
          },
        ],
        editors: [
          {
            name: "David Honey",
            mailto: "DavidHoney@uk.ibm.com",
            company: "IBM",
            companyURL: "https://www.ibm.com/",
          },
        ],
      };
    </script>
    <style>
      table,
      th,
      td {
        border: 1px solid #666;
        border-collapse: collapse;
      }
      table th,
      table td {
        padding: 5px; /* Apply cell padding */
      }

      hr {
        border: none;
        border-top: 1px double #666;
        color: #666;
        overflow: visible;
        height: 0px;
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>This primer serves as a guide to the concepts in the specification, and through the use of simple examples, explains how versioning and configurations are represented, how and when local configurations and global configurations are used, and lists the elements that an implementation should consider.</p>
    </section>

    <section id="toc"></section>
    <section id="sotd"></section>

    <section id="outline" class="level1">
    <h1>Outline</h1>
    <p>The OSLC Configuration Management specification is a reference for servers that want to expose configuration management to OSLC clients. However, the specification is not organized as a tutorial or introduction about how to implement an OSLC configuration management compliant server or adapter.</p>
    <p>This primer serves as a guide to the concepts in the specification, and through the use of simple examples, explains how versioning and configurations are represented, how and when local configurations and global configurations are used, and lists the elements that an implementation should consider. The specification remains the definitive source, and where this primer differs from the specification, the specification should be taken as the authoritative reference.</p>
    </section>
    <section id="motivation" class="level1">
    <h1>Motivation</h1>
    <section id="problem" class="level2">
    <h2>Problem</h2>
    <p>Any software development project team creating anything but the simplest, short-lived solutions knows the value of source code management (SCM). Without SCM, teams could not reliably recreate the source files that were used to build a specific release, making it impossible to reliably maintain what the team has delivered.</p>
    <p>However, a large development project involves much more shared information that just source files. Complex products and systems are mix of software, electronics, and hardware, with software taking an increasing role. Solution components are often developed by different organizations, using different method and tools, with lifecycle information stored in different repositories. The design and development of these complex systems requires many kinds of artifacts. Engineers in specialist disciplines produce these artifacts employing various engineering methods, disciplines and tools. Often these artifacts are not under Configuration Management, or if they are, it is done manually with half-measures that incur trade-offs. These challenges exist for software-only systems, yet their magnitude is much greater for products with physical, electrical and software aspects.</p>
    <p>For example, specific requirements are often associated with a particular release of components of a system. Analysis and design artifacts are created to understand how to address the impact of, or realize those requirements. Test cases and test results are used to validate that the work done on the systems actually meets the requirements.</p>
    <p>All this shared information is generally not available under the control of a single organization, set of tools or content management system, and it is often stored in repositories, not files in the file system. Like source files, all this shared information should be managed in a controllable, predictable way that is coordinated with specific solution releases.</p>
    <p>Development teams need an efficient, effective means of managing versions and variants of artifacts across the whole systems development lifecycle. They need to be able to capture, preserve, compare, merge and potentially recreate specific sets of versioned information covering the whole lifecycle in order to know who did what, when, and why.</p>
    </section>
    <section id="solution" class="level2">
    <h2>Solution</h2>
    <p>The OSLC Configuration Management specification defines an RDF vocabulary and a set of REST APIs for managing versions and configurations of linked data resources from multiple domains. Using client and server applications that implement the configuration management vocabulary and REST APIs allow a team administrator to create configurations of versioned resources contributed from tools and data sources across the lifecycle. These contributions can be assembled into aggregate (global) configurations that are used to resolve references to artifacts in a particular and reproducible context.</p>
    <p>Team members set the configuration context in each of the tools they use to refer to the particular global configuration that represents the state of the systems they are working on. They can create branches to support parallel development, and compare and merge branches to flow changes as needed. Product managers can create branches that represent different variants of a product in order to separate variation points and ensure changes are only applied to the appropriate variants.</p>
    <p>Development teams can create baselines that preserve the state of the federated, shared information in order to be able to recreate that state for any reason, including for regulatory compliance or for applying maintenance updates to released versions and/or variants of a product.</p>
    </section>
    <section id="business-value" class="level2">
    <h2>Business Value</h2>
    <p>The primary purpose for versioning and configuration management is to be able to establish and restore or recover a particular set of related resources in order to know and manage who changed what, when, and why. Applying these techniques to other disciplines, and combining them together, offers new opportunities for parallel development, managing change, reuse, and management of product variants in complex development projects.</p>
    <p>The benefits of source-code management are well known. However, achieving those benefits across all of the information that goes into designing, building, managing and governing the source code can be a challenge. This is because having multiple change and configuration management solutions for different artifact types requires manual coordination of versions and variants across the tools. The OSLC Configuration Management specification specifies a standard way in which different tools, developed by different suppliers, at different times, using different repositories and data representations can contribute version and configuration information across the whole lifecycle.</p>
    <p>The resulting business value includes:</p>
    <ul>
    <li>Cross-tool version and configuration management related shared information</li>
    <li>Support for context-specific link navigation and management</li>
    <li>Automatic configuration management of complex solutions and systems</li>
    <li>Enable parallel, independent, development streams with branching and merging of all lifecycle information</li>
    <li>Save and restore consistent sets of related information for any purpose including regulatory compliance and product maintenance releases</li>
    <li>Manage different variants of a related set of deliverables, solutions and/or products</li>
    <li>Reuse utilizing commonality/variability for Product Line Engineering (PLE)</li>
    </ul>
    <p>Some typical uses of versioning and configuration management capabilities include:</p>
    <ul>
    <li>Creating baselines of development streams in order to capture and preserve the state of a system at different points in time</li>
    <li>Use release stabilization streams to complete development of specific releases while allowing ongoing future development to continue in parallel Branching streams for different purposes including experimentation, A/B testing, gradual production rollout, importing from a supplier, etc., and delivering changes on streams to a common shared stream in a controlled manner.</li>
    <li>Parallel development on shared artifacts, overlapping releases or the common parts of product variants with the ability to compare different streams and flow changes as needed to meet requirements, enforce enterprise asset management and governance, and promote reuse.</li>
    <li>Create maintenance branches and control propagation of maintenance changes into ongoing development streams in a controlled, predictable manner</li>
    <li>Managing configurations of related, federated, shared information across the whole lifecycle.</li>
    <li>Isolate changes for different variants on different streams while also managing common, reusable components.</li>
    <li>Enable reuse of lifecycle artifacts including requirements and test cases, as well as the relationships between them, including regulatory and security requirements and test cases.</li>
    <li>Enable analysts and designers to work one iteration ahead in agile projects in order to better inform iteration planning and development.</li>
    <li>Enable progressive contribution of parts of a large system with baselines that capture each significant evolution of the system.</li>
    <li>Support different approaches to reuse by branching from product streams that are closes to the new variant, or branching from a common base that is maintained as a reusable enterprise asset.</li>
    <li>Enable concurrent development of shared enterprise assets in different product delivery streams (requirements delivery life-cycles) while at the same time managing and governing changes to long-lived enterprise assets (asset management life-cycles).</li>
    </ul>
    </section>
    </section>
    <section id="concepts" class="level1">
    <h1>Concepts</h1>
    <p><a href="https://en.wikipedia.org/wiki/Configuration_management">Configuration Management on Wikipedia</a> defines Configuration Management as follows: &gt; Configuration management (CM) is a systems engineering process for establishing and maintaining consistency of a product’s performance, functional, and physical attributes with its requirements, design, and operational information throughout its life.</p>
    <p>In Configuration Management, artifacts are versioned. For example, a new requirement R1 might be defined and created. Once the content of that requirement is checked in or committed, version 1 of that requirement R1 exists. At that point, the contents of version 1 cannot be changed. If changes are required, the content is changed, and when checked in or delivered, results in version 2 of requirement R1. Version 2 of R1 was created from, or derived from, version 1 of R1. The sequence of versions of that requirement comprise its <em>version history</em>. In OSLC Configuration Management, the term <em>concept resource</em> is used to mean all the versions of some artifact. In our example, requirement R1 is a concept resource (no version is specified), and requirement R1 version 1 is a specific version of that concept resource. Many versioning systems exist, and there are a number of different approaches as to how artifacts are versioned, when those versions are created, and when a version becomes non-modifiable. However, all versioning systems support some notion of when a change is committed, the version that records that change becomes non-modifiable. The OSLC Configuration Management specification does not define how versioning should be implemented. For example, some versioning systems assign <em>version identifiers</em> separately for each versioned resource, while other versioning system version an entire repository so that a version identifier is “global” across all versioned resources. Servers are free to choose existing versioning systems, or implement a versioning system of their own design.</p>
    <p>An important element of Configuration Management is a <em>configuration</em>. A configuration defines what set of version resources are used in that configuration. For example, configuration C1 might use version 1 of requirement R1, and configuration C2 might use version 2 of requirement R1. New artifacts might be added to or obsolete artifacts removed from a configuration. The configuration therefore provides a view of the appropriate artifacts and versions of those artifacts that apply in that configuration. The OSLC Configuration Management specification defines this in terms of <em>selections</em>. A configuration might reference a <em>selections</em> resource that in turn references the specific version resources that belong in that configuration.</p>
    <p>In OSLC Configuration Management, a <em>stream</em> is a modifiable configuration in which artifacts may be added or removed, or a different version of an artifact may be selected by a user to replace some other version of that artifact. Streams are the configurations in which ongoing work is performed. An essential element of Configuration Management is the ability to create a non-modifiable record of the set of version resources at specific milestones or points in time in order to provide traceability and auditing. In OSLC Configuration Management, a <em>baseline</em> is a non-modifiable configuration whose set of version resources are also non-modifiable. Usually a baseline is created from a stream, recording the state of that stream. The stream continues to be modifiable, but the baseline is now a non-modifiable record of the state of the stream at the time the baseline was created. Every configuration is associated with a <em>component</em>. A <em>component</em> is a unit of organization consisting of a set of version resources. When a <em>baseline</em> is created from a <em>stream</em>, both the baseline and the stream are for the same <em>component</em>. The granularity of a component is up to an application designer.</p>
    <p>OSLC Configuration Management supports the idea that a configuration may be a container of other configurations. The term <em>contribution</em> describes a resource that has both a <em>contribution order</em> property and a reference to a configuration that is used by a parent configuration. Strictly speaking, the term <em>contribution</em> means a contribution resource, but is sometimes used informally as a shorthand for child configuration which is a <em>contributed configuration</em>. Configurations may thus form a <em>hierarchy</em> of configurations. The term <em>global configuration</em> is used to describe a configuration that aggregates configurations, especially those from other configuration management servers. For example, a global configuration might have contributions from a requirements management server, a quality management server, and a source code control server. The global configuration thus represents the state of version resources across those application servers.</p>
    <p>There is a UML class diagram in section 7 that describes how these concepts, and those in following sections, relate to the resources described in the OSLC Configuration Management Specification.</p>
    </section>
    <section id="representation-of-version-resources" class="level1">
    <h1>Representation of version resources</h1>
    <p>We will use an example of two requirements, A and B, in order to explain some of the concepts and representations. From a concept resource point of view, one might think of the requirements as having some basic properties as shown below. Requirement B <em>refines</em> requirement A.</p>
    <pre><code>Requirement_a
    id: a
    name: &quot;Requirement A&quot;
    description: &quot;A description of requirement A&quot;


    Requirement_b
    id: b
    name: &quot;Requirement B&quot;
    description: &quot;A description of requirement B&quot;
    refines: Requirement_a</code></pre>
    <p>Let’s look at a possible RDF representation of requirement A version 1 (<code>requirementA-v1</code>). The RDF graph of <code>requirementA-v1</code> might look something like:</p>
    <pre><code>:requirementA-v1
        a oslc_config:VersionResource ;
        dcterms:isVersionOf :requirementA .
    :requirementA
        a oslc_rm:Requirement ;
        oslc_config:versionId &quot;v1&quot; ;
        oslc_config:component :rmComponent1 ;
        dcterms:identifier &quot;A&quot; ;
        dcterms:title &quot;Requirement A&quot;^^rdf:XMLLiteral ;
        dcterms:description &quot;A description of requirement A version 1&quot;^^rdf:XMLLiteral .</code></pre>
    <p>There are two important things to note: 1. The main properties of the requirement are made using a subject URI of the <em>concept resource</em> <code>:requirementA</code> and <strong>not</strong> the URI of the specific version <code>:requirementA-v1</code>. This is done so that the same subject is used for properties of all the versions of that concept resource. A query against the concept URI <code>:requirementA</code> and <code>dcterms:description</code> would give the descriptions of requirement A across all versions. 2. There are a few statements made using the subject URI of the version resource <code>:requirementA-v1</code> that specify the artifact is a version resource and its concept resource.</p>
    <p>Now consider that requirement A has been updated with a new description, resulting in version 2 (<code>requirementA-v2</code>):</p>
    <pre><code>:requirementA-v2
        a oslc_config:VersionResource ;
        dcterms:isVersionOf :requirementA ;
        prov:wasRevisionOf :requirementA-v1 .
    :requirementA
        a oslc_rm:Requirement ;
        oslc_config:versionId &quot;v2&quot; ;
        oslc_config:component :rmComponent1 ;
        dcterms:identifier &quot;A&quot; ;
        dcterms:title &quot;Requirement A&quot;^^rdf:XMLLiteral ;
        dcterms:description &quot;A description of requirement A version 2 (changed description)&quot;^^rdf:XMLLiteral .</code></pre>
    <p>The statements using subject URI <code>:requirementA-v2</code> include <code>prov:wasRevisionOf :requirement-v1</code>, indicating that version 2 was derived from or created from version 1 of requirement A. The <code>dcterms:description</code> of the concept resource specifies the changed description for version 2.</p>
    <p>Similarly, one might have requirement B version 1 (<code>requirementB-v1</code>):</p>
    <pre><code>:requirementB-v1
        a oslc_config:VersionResource .
        dcterms:isVersionOf :requirementB .
    :requirementB
        a oslc_rm:Requirement ;
        oslc_config:versionId &quot;v1&quot; ;
        oslc_config:component :rmComponent1 ;
        dcterms:identifier &quot;B&quot; ;
        dcterms:title &quot;Requirement B&quot;^^rdf:XMLLiteral ;
        dcterms:description &quot;A description of requirement B version 1&quot;^^rdf:XMLLiteral ;
        oslc_rm:refines :requirementA.</code></pre>
    <p>Note that the <code>oslc_rm:refines</code> link is to the <em>concept resource</em> of requirement A <code>:requirementA</code> and <strong>not</strong> to a version of that requirement. While an implementation <em>could</em> link to a specific version resource, that’s usually undesirable. Consider what would happen if <code>requirementB-v1</code> referenced <code>requirementA-v1</code>. When version 2 of requirement A is created, one might want requirement B to reference it. This would require that a new version 2 of requirement B be created in order to update that link. This results in a lot of new versions because the links themselves are referencing specific versions. If the link references the concept resource, the <em>resolution</em> of which version of requirement A is referenced, is decoupled and deferred. A user that views requirements A and B in a particular <em>configuration context</em> will see the versions of both requirements <em>resolved</em> in that configuration context. If requirement A was updated to version 2 in that context, then <code>requirementB-v1</code> will have a <em>refines</em> link that now <em>resolves</em> to <code>requirementA-v2</code>. This avoids the need to update requirement B to reference that new version of requirement A.</p>
    <p>Typically applications provide some means for a user to select their <em>configuration context</em> in their user interface. For work in progress, this is usually a stream. If the user wants to see the versions of artifacts that were used at an important milestone, they would typically select the baseline that was created for that milestone. From a REST API standpoint, a configuration context can be specified using either a <code>Configuration-Context</code> header or a <code>oslc_config.context</code> parameter in the request.</p>
    </section>
    <section id="local-configurations" class="level1">
    <h1>Local configurations</h1>
    <p>A configuration created in and used by an application to manage the selected versions in that configuration is called a <em>local configuration</em>. Using the previous example based on requirements, let’s imagine we have a stream in a requirements management application that selects requirements <code>requirementA-v1</code> and <code>requirementB-v1</code>. The RDF representation of that stream might be as follows:</p>
    <pre><code>:rmStream1
        a oslc_config:Stream ;
        dcterms:title &quot;First requirements management stream&quot;^^rdf:XMLLiteral ;
        oslc_config:component :rmComponent1 ;
        oslc_config:selections :rmStream1Selections ;
        oslc_config:acceptedBy oslc_config:Configuration .</code></pre>
    <p>A configuration always has a component. The stream references zero, one, or more <em>selections</em> resource(s) that specify what version resources are selected by the stream. In our example, the selections resource might be as follows:</p>
    <pre><code>:rmStream1Selections
        oslc_config:selects :requirementA-v1, :requirementB-v1 .</code></pre>
    <p>A user might want to capture the state of that stream by creating a <em>baseline</em>. The RDF representation of such a baseline might be as follows:</p>
    <pre><code>:rmBaseline1
        a oslc_config:Baseline;
        dcterms:title &quot;First requirements management stream (first baseline)&quot;^^rdf:XMLLiteral ;
        oslc_config:component :rmComponent1 ;
        oslc_config:selections :rmBaseline1Selections ;
        oslc_config:baselineOfStream :rmStream1 ;
        oslc_config:acceptedBy oslc_config:Configuration .</code></pre>
    <p>The <code>oslc_config:baselineOfStream</code> property specifies the stream that the baseline was created from. The selections resource referenced by that baseline might be as follows:</p>
    <pre><code>:rmBaseline1Selections
        oslc_config:selects :requirementA-v1, :requirementB-v1 .</code></pre>
    <p>Creating that baseline from the stream results in that stream’s representation including an [updated] <code>oslc_config:previousBaseline</code> property:</p>
    <pre><code>:rmStream1
        a oslc_config:Stream ;
        dcterms:title &quot;First requirements management stream&quot;^^rdf:XMLLiteral ;
        oslc_config:component :rmComponent1 ;
        oslc_config:selections :rmStream1Selections ;
        oslc_config:acceptedBy oslc_config:Configuration ;
        oslc_config:previousBaseline :rmBaseline1 .</code></pre>
    <p>When requirement A was changed to create version 2, the stream <code>rmStream1</code> would be updated to select that version:</p>
    <pre><code>:rmStream1Selections
        oslc_config:selects :requirementA-v2, :requirementB-v1 .</code></pre>
    <p>The baseline <code>rmBaseline1</code> continues to select <code>:requirementA-v1</code> and <code>:requirementB-v1</code>. The selections of a baseline cannot be modified. The baseline therefore serves as a non-modifiable record of the state of the stream from which it was created at a specific point in time.</p>
    </section>
    <section id="global-configurations" class="level1">
    <h1>Global configurations</h1>
    <p>A <em>global configuration</em> is a configuration used to assemble other configurations (typically from other application servers) into a hierarchy. To understand the usage, let’s consider that we have a quality management application that has a test case <code>testCaseA</code> that validates <code>requirementA</code>. Version 1 of that test case might have an RDF representation as follows:</p>
    <pre><code>:testCaseA-v1
        a oslc_config:VersionResource ;
        dcterms:isVersionOf :testCaseA ;
    :testCaseA
        a oslc_qm:TestCase ;
        dcterms:title &quot;Test case validating requirement A&quot;^^rdf:XMLLiteral ;
        dcterms:description &quot;Details of how the test case validates requirement A&quot;^^rdf:XMLLiteral ;
        oslc_qm:validatesRequirement :requirementA .</code></pre>
    <p>In this example, the quality management application has its own local stream that selects <code>testcaseA-v1</code>:</p>
    <pre><code>:qmStream1
        a oslc_config:Stream ;
        dcterms:title &quot;First quality management stream&quot;^^rdf:XMLLiteral ;
        oslc_config:component :qmComponent1 ;
        oslc_config:selections :qmStream1Selections ;
        oslc_config:acceptedBy oslc_config:Configuration .</code></pre>
    <p>with its referenced selections resource:</p>
    <pre><code>:qmStream1Selections
        oslc_config:selects :testCaseA-v1 .</code></pre>
    <p>A user looking at test cases in the context of configuration <code>qmStream1</code> would see <code>testCaseA-v1</code>. That test case has a <em>validates requirement</em> link to requirement A. However, in that configuration context, it is not possible to <em>resolve</em> the link to a version of the requirement concept resource because that is managed by the requirement management application and not the quality management application.</p>
    <p>This is where a <em>global configuration</em> is useful. As an example, say we have a global stream that has <em>contributions</em> from <code>rmStream1</code> and <code>qmStream1</code>. Its RDF representation might be as follows:</p>
    <pre><code>:globalStream1
        a oslc_config:Stream ;
        dcterms:title &quot;First global stream&quot;^^rdf:XMLLiteral ;
        oslc_config:accepts oslc_config:Configuration ;
        oslc_config:acceptedBy oslc_config:Configuration ;
        oslc_config:contribution :contribution1, :contribution2 .
    :contribution1:
        oslc_config:configuration :rmStream1 ;
        oslc_config:contributionOrder &quot;1&quot; .
    :contribution2:
        oslc_config:configuration :qmStream1 ;
        oslc_config:contributionOrder &quot;2&quot; .</code></pre>
    <p>A user is working in the configuration context <code>globalStream1</code>. In the requirements management application, when the user looks at the requirements for component <code>rmComponent1</code>, they see <code>requirementA-v2</code> and <code>requirementB-v1</code>. The requirements management application resolves the component <code>rmComponent1</code> in the context of global configuration <code>globalStream1</code>. The global configuration has only one contribution associated with <code>rmComponent1</code> and that’s for the local configuration <code>rmStream1</code>. That local configuration selects <code>requirementA-v2</code> and <code>requirementB-v1</code>. Similarly, in the quality management application, when the user looks at the test cases for component <code>qmComponent1</code>, they see <code>testCaseA-v1</code>.</p>
    <p>For that test case, the quality management user sees the <em>validates requirement</em> link to <code>requirementA-v2</code>. The quality management application only knows the link is to the test case concept resource <code>requirementA</code> and cannot resolve which version of that requirement is referenced. This is because the requirements management application that owns that requirement manages the configurations that select it. So how does the quality management application resolve the link to the requirement to a specific version?</p>
    <p>When referencing that requirement, it uses a <code>oslc_config.context</code> query parameter or a <code>Configuration-Context</code> header with a value that is the URI of the configuration context. For example <code>":requirementA?oslc_config.context=':globalStream1'"</code>. The parameter value is shown here without URL encoding for clarity. In practice, parameter values should be URL encoded. When the requirements management application gets a request to fetch that requirement, it resolves the concept resource URI in the specified configuration context. In this example, it knows that the requirement concept resource <code>requirementA</code> is owned by component <code>rmComponent1</code>, and resolves that component in the global configuration context <code>globalStream1</code> to the local configuration <code>rmStream1</code>, and then resolves the requirement concept resource <code>requirementA</code> to <code>:requirementA-v2</code>.</p>
    <p>How does an application resolve a component in a global configuration context to a local configuration?</p>
    <p>Say an RM application wants to resolve component <code>rmComponent1</code> in the context of <code>globalStream1</code>. The starting point is to consider the hierarchy of the global configuration <code>:globalStream1</code> and associated components. The previous example yields the tree shown below:</p>
    <pre><code>    globalStream1 (component=globalComponent1)
            rmStream1 (component=rmComponent1, order=1)
            qmStream1 (component=qmComponent1, order=2)</code></pre>
    <p>An application traverses this tree looking for component <code>rmComponent1</code> and finds <code>rmStream1</code>. When the tree only contains a single configuration for a particular component, the order of traversal does not matter.</p>
    <p>In practice, constructing a contribution tree by fetching data each time a component needs to be resolved to a local configuration does not scale well or provide the performance required for frequent resolution. Implementations commonly use some form of caching of that data and use an implementation dependent way of maintaining that cached data.</p>
    <p>Global configurations therefore fulfill two important functions: * They allow a configuration context to be used across applications that allow an application to resolve their concept resources to the right versions. * They allow links between concept resources in <em>different</em> applications to be viewed and navigated to the right versions of those artifacts in that configuration context.</p>
    <p>The distinction between a local configuration and a global configuration is a fuzzy one. Consider a requirements management server that supports configurations that have contributions from other configurations in the same server but not other servers. Should such a configuration be called a local configuration or a global configuration? The distinguishing characteristics of a global configuration are that they are normally usable as contributions in any other global configuration and may use contributions from any local or global configuration. So such a configuration would be more accurately termed a local configuration even though it has contributions.</p>
    </section>
    <section id="uml-class-diagram" class="level1">
    <h1>UML Class diagram</h1>
    <p>The UML class diagram below shows the main elements of the configuration management specification. It intentionally omits some relationships for the sake of clarity. The resource shapes in the specification remain the definitive reference. <img src="https://lucid.app/publicSegments/view/d6da1584-ba23-4b93-a2a9-c0f8aca038b9/image.png" /></p>
    <p>Some key aspects of the representation are: * The version resources selected by a configuration are determined using the property path <code>oslc_config:selections/oslc_config:selects</code>. * The immediate contributed configurations to a configuration are determined using the property path <code>oslc_config:contribution/oslc_config:configuration</code>. Contribution resources are embedded within configurations. * Global configurations often only have contributions and not selections. * Local configurations often only have selections and not contributions.</p>
    </section>
    <section id="component-skew-and-contribution-order" class="level1">
    <h1>Component skew and contribution order</h1>
    <p>Consider a global stream <code>globalStream2</code> that has contributions from <code>rmStream1</code>, <code>rmBaseline1</code>, and <code>:qmStream1</code> in that order. <code>rmStream1</code> and <code>rmBaseline1</code> are for the same <em>component</em>. Where a configuration hierarchy has contributions from two <em>different</em> configurations of the same component, this is called <em>component skew</em>.</p>
    <p>Now consider the contribution tree for <code>globalStream2</code>:</p>
    <pre><code>    globalStream2 (component=globalComponent1)
            rmStream1 (component=rmComponent1, order=1)
            rmBaseline1 (component=rmComponent1, order=2)
            qmStream1 (component=qmComponent1, order=3)</code></pre>
    <p>When resolving the concept <code>requirementA</code> in the context of <code>globalStream2</code>, should this resolve to <code>requirementA-v2</code> selected by <code>rmStream1</code> or <code>requirementA-v1</code> selected by <code>rmBaseline1</code>? The component skew is resolved by the order in which the contribution tree is traversed. If the traversal algorithm orders <code>rmStream1</code> before <code>rmBaseline1</code>, then component <code>rmComponent1</code> resolves to <code>rmStream1</code>, and the <code>requirementA</code> resolves to <code>requirementA-v2</code>.</p>
    <p>The configuration management specification does not prescribe a traversal algorithm, but a common approach is to perform a depth-first, sibling ordered by contribution order second traversal. Consider the following configuration hierarchy:</p>
    <pre><code>    globalStream2 (component=globalComponent1)
            globalStream3 (component=globalComponent2, order=1)
                rmStream1 (component=rmComponent1, order=1)
            globalStream4 (component=globalComponent3, order=2)
                rmBaseline1 (component=rmComponent1, order=1)
                qmStream1 (component=qmComponent1, order=2)</code></pre>
    <p>A depth-first, sibling ordered by contribution order second traversal results in the following traversal order:</p>
    <pre><code>    globalStream2
        globalStream3
        rmStream1
        globalStream4
        rmBaseline1
        qmStream1</code></pre>
    <p>Note that the contribution order should be sorted as an ASCII string rather than being treated as a numeric string.</p>
    </section>
    <section id="branching" class="level1">
    <h1>Branching</h1>
    <p>The OSLC Configuration Management specification does not define whether a versioning system should support branching and/or parallel versions, and if so how these are managed. Some versioning systems support branches as first-class objects, and there are actions to create branches. Some versioning system handling branching by copying data into different paths in the repository, referencing the shared artifacts. Other versioning systems regard branching as simply parallel versions, perhaps for different variants or purposes. Because of these different approaches, branching is not covered by the specification so that it remains implementable across a wider range of systems.</p>
    <p>From an OSLC standpoint, clients create new versions of concept resources by a PUT on the concept URI with a configuration context specifying the stream that will be updated to use the new version. The version that was previously used in that stream is the predecessor version of the newly created version. For example, if <code>:rmStream1</code> uses <code>requirementA-v1</code>, a new version <code>requirementA-v2</code> might be created from it by a <code>PUT requirementA?oslc_config.context=%3ArmStream1</code>. If a client then requests a new version be created from <code>requirementA-v1</code> in some other stream, an implementation that supports branching might create <code>requirementA-v2.1</code> as a parallel version to <code>requirementA-v2</code>. An implementation that only supports linear versioning might fail the request.</p>
    <p>Typically, parallel development for different branches or purposes is performed in separate <em>streams</em>. For example, parallel streams might be created from the same baseline in order to work on separate features for some release. The OSLC Configuration Management specification does not define any mechanisms for merging streams. However, a client can PUT merged content to the concept resource where the merged content has multiple <code>prov:wasRevisionOf</code> statements indicating the contents were merged from those predecessor versions.</p>
    </section>
    <section id="implementation-elements" class="level1">
    <h1>Implementation elements</h1>
    <section id="introduction" class="level2">
    <h2>Introduction</h2>
    <p>When adding support for OSLC Configuration Management to an application, or writing an adapter to provide such support to an existing application, there are a number of elements to the implementation. To gain the full power of configuration management, an implementation should support both version resources and configurations. An implementation need not follow the ordering of the following sections. However, the ordering reflects some of the dependencies that an implementation is likely to face. For example, versioned artifacts belong to a component, so support for components might be better implemented before versioned artifacts. Within each section, a minimal set of elements is described, followed by optional elements. An implementation might want to tackle the minimal elements first, then revisit each of the sections and consider tackling some or all of the optional elements.</p>
    <p>Some applications support a notion of a <em>project</em> or <em>project area</em> that serve as a container of resources and for managing access to those resource in that container. While this notion is not part of any OSLC specification, it is mentioned here because it may affect the implementation. Applications that support this or similar containers, might want to declare a separate <code>oslc:ServiceProvider</code> for each such container. For example, this is a common convention for IBM Jazz applications.</p>
    </section>
    <section id="components" class="level2">
    <h2>Components</h2>
    <section id="minimal-elements" class="level3">
    <h3>Minimal elements</h3>
    <p>At a minimum, an implementation should provide REST support for: * <code>GET</code> of a component URI. The RDF of a component should include a <code>oslc_config:configurations</code> statement to a <em>Linked Data Platform Container</em> (LDPC). The response should include an <code>Etag</code> header whose value represents the state of the component. * <code>PUT</code> of a component. The implementation should require the use of an ‘If-match’ header whose value matches the current Etag. * <code>GET</code> of a component’s configurations LDPC, returning a container that references all the configurations of that container.</p>
    <p>While it is valid to create a component that initially does not have any configurations, it is good practice when creating a component to do either of: * Create an empty initial baseline, then create an empty default stream from that baseline. * Create an empty default stream.</p>
    </section>
    <section id="optional-elements" class="level3">
    <h3>Optional elements</h3>
    <ul>
    <li>Support resource shapes for components. Each component should include in its RDF representation an <code>oslc:instanceShape</code> property that references a resource shape for that component.</li>
    <li>Support an OSLC selection dialog of components. This should be declared in an <code>oslc:Service</code> that is discoverable from a <code>oslc:ServiceProviderCatalog</code>.</li>
    <li>Support for an <code>oslc:CreationFactory</code> for components. This should be declared in an <code>oslc:Service</code> that is discoverable from a <code>oslc:ServiceProviderCatalog</code>. The creation factory should reference a resource shape for components.</li>
    <li>Support <code>POST</code> on a component’s configurations LDPC as a means of creating a new stream for that component.</li>
    <li>Support OSLC query on components. An <code>oslc:QueryCapability</code> should be declared in an <code>oslc:Service</code> that is discoverable from a <code>oslc:ServiceProviderCatalog</code>. The query capability should reference a resource shape for the query container, and that resource shape should reference a value shape for the components that might be returned in that container.</li>
    </ul>
    </section>
    </section>
    <section id="configurations" class="level2">
    <h2>Configurations</h2>
    <section id="minimal-elements-1" class="level3">
    <h3>Minimal elements</h3>
    <p>At a minimum, an implementation should provide REST support for: * <code>GET</code> on a configuration URI. If the application manages versioned resources, the RDF representation should include a <code>oslc_config:selections</code> statement to a selections resource. The response should include an <code>Etag</code> header whose value represents the state of that stream. * <code>PUT</code> of a configuration. The implementation should require the use of an ‘If-match’ header whose value matches the current Etag. * <code>GET</code> on a selections resource (if the application manages versioned resources). The RDF representation should include a <code>oslc_config:select</code> statement to each version resource URI selected by that configuration.</p>
    </section>
    <section id="optional-elements-1" class="level3">
    <h3>Optional elements</h3>
    <ul>
    <li>Support resource shapes for configurations. Each configuration should include in its RDF representation an <code>oslc:instanceShape</code> property that references a resource shape for that configuration.</li>
    <li>Support <code>oslc_config:streams</code> property in the RDF of a baseline, and support a <code>GET</code> on that LDPC. Optionally support <code>POST</code> on that LDPC as a means of creating a stream from the baseline.</li>
    <li>Support <code>oslc_config:baselines</code> property in the RDF of a stream, and support a <code>GET</code> on that LDPC. Optionally support <code>POST</code> on that LDPC as a means of creating a baseline from the stream.</li>
    <li>Support an OSLC selection dialog of configurations. This should be declared in an <code>oslc:Service</code> that is discoverable from a <code>oslc:ServiceProviderCatalog</code> and its referenced <code>oslc:serviceProvider</code> members.</li>
    <li>Support for an <code>oslc:CreationFactory</code> for configurations. This should be declared in an <code>oslc:Service</code> that is discoverable from a <code>oslc:ServiceProviderCatalog</code> and its referenced <code>oslc:serviceProvider</code> members. The creation factory should reference a resource shape for configurations.</li>
    <li>Support OSLC query on configurations. An <code>oslc:QueryCapability</code> should be declared in an <code>oslc:Service</code> that is discoverable from a <code>oslc:ServiceProviderCatalog</code> and its referenced <code>oslc:serviceProvider</code> members. The query capability should reference a resource shape for the query container, and that resource shape should reference a value shape for the configurations that might be returned in that container.</li>
    <li>Support <code>DELETE</code> of a local configuration.</li>
    </ul>
    </section>
    </section>
    </section>
    <section id="concept-resources-and-version-resources" class="level1">
    <h1>Concept resources and version resources</h1>
    <section id="minimal-elements-2" class="level2">
    <h2>Minimal elements</h2>
    <p>At a minimum, an implementation should provide REST support for: * <code>GET</code> on a version resource URI. The RDF representation of the version resource should: * Include statements against the version URI declaring it of type <code>oslc_config:versionResource</code>, and <code>dcterms:isVersionOf</code> referencing the concept resource URI. * Include statements about the properties of the resource using the concept resource URI as the subject. * <code>GET</code> on a concept resource with a local configuration context specified by a <code>oslc_config.context</code> query parameter or header. This should resolve the concept resource to the version resource and return the RDF of that version resource. This requires that the application be able to determine the component to which a specified concept resource belongs.</p>
    </section>
    <section id="optional-elements-2" class="level2">
    <h2>Optional elements</h2>
    <ul>
    <li>Support <code>GET</code> on a concept resource with a global configuration context specified by a <code>oslc_config.context</code> query parameter or header. This should resolve the concept resource in the context of that global configuration to the version resource and return the RDF of that version resource. This is required if the application is to be used with global configurations. The only mechanism for resolving a local component to a local configuration in a global configuration context covered by the specification is for an application to <code>GET</code> the global configuration to discover its contributions, and then repeat this recursively on the contributions to discover the contribution hierarchy. Doing this each time resolution is required is likely to be expensive. Implementations should consider whether some form of local caching of contribution trees is required to meet performance goals of the application.</li>
    <li>Support <code>GET</code> on a concept resource without a configuration context specified by a <code>oslc_config.context</code> query parameter or header. The application should determine a <em>default configuration</em>, and then use that as the configuration to resolve the concept resource. should resolve the concept resource in the context of that global configuration to the version resource and return the RDF of that version resource. This is required if the application is to be used with global configurations.</li>
    <li>Support <code>POST</code> to a component with a <code>oslc_config.context</code> query parameter or <code>Configuration-Context</code> header to create a new concept resource.</li>
    <li>Support <code>PUT</code> to a concept resource with a <code>oslc_config.context</code> query parameter or <code>Configuration-Context</code> header specifying a stream in which to create a new version from a currently used version.</li>
    <li>Support <code>DELETE</code> of a version resource with a <code>oslc_config.context</code> query parameter or header to delete the current mutable version resource from a specified stream.</li>
    <li>Support an <code>oslc:CreationFactory</code> that can create new concept resources and their initial version in the context of a configuration.</li>
    </ul>
    </section>
    </section>
    <section id="references" class="level1">
    <h1>References</h1>
    <p><a href="https://oslc-op.github.io/oslc-specs/specs/config/oslc-config-mgt.html">https://oslc-op.github.io/oslc-specs/specs/config/oslc-config-mgt.html</a></p>
    </section>
  </body>
</html>

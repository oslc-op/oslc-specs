<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Tracked Resource Set 1.0 Primer</title>
    <meta charset="utf-8" />
    <meta name="description" content="This primer serves as a guide to the concepts in the TRS specification, and through the use of simple examples, explains how a data provider might expose resources in a TRS and how a TRS client might consume a data provider’s TRS." />

    <!-- <script
      src="https://cdn.jsdelivr.net/gh/oasis-tcs/tab-respec@v2.1.30/builds/respec-oasis-common.min.js"
      async
      class="remove"
    ></script> -->
    <script src="http://127.0.0.1:9000/respec-oasis-common.js" async class="remove"></script>
    <script class="remove">
      var respecConfig = {
        shortName: "trs-primer",
        specStatus: "PN",
        revision: "01",
        publishDate: "2021-11-04T18:00Z",

        edDraftURI: "https://oslc-op.github.io/oslc-specs/notes/config-primer/config-primer.html",
        thisVersion: "https://docs.oasis-open-projects.org/oslc-op/notes/config-primer/pn01/config-primer.html",
        // prevVersion: null,
        // latestVersion: "https://oslc-op.github.io/oslc-specs/notes/config-primer/config-primer.html",
        // latestSpecVersion: "https://oslc-op.github.io/oslc-specs/notes/config-primer/config-primer.html",

        // Other parts of multi-part spec
        additionalArtifacts: [],

        relatedWork: [],

        localBiblio: {
          OSLCCore3: {
            title: "OSLC Core 3.0",
            href: "https://docs.oasis-open.org/oslc-core/oslc-core/v3.0/csprd03/part1-overview/oslc-core-v3.0-csprd03-part1-overview.html",
            authors: ["Jim Amsden", "S. Speicher"],
            status: "Committee Specification Public Review Draft",
            publisher: "OASIS",
          },
          OSLCCoreVocab: {
            title: "OSLC Core Vocabulary",
            href: "https://docs.oasis-open.org/oslc-core/oslc-core/v3.0/csprd03/part7-core-vocabulary/oslc-core-v3.0-csprd03-part7-core-vocabulary.html",
            authors: ["Jim Amsden", "S. Padgett", "S. Speicher"],
            status: "Committee Specification Public Review Draft",
            publisher: "OASIS",
          },
          OSLCShapes: {
            title: "OSLC Resource Shape 3.0",
            href: "https://docs.oasis-open.org/oslc-core/oslc-core/v3.0/csprd03/part6-resource-shape/oslc-core-v3.0-csprd03-part6-resource-shape.html",
            authors: ["Arthur Ryman", "Jim Amsden"],
            status: "Committee Specification Public Review Draft",
            publisher: "OASIS",
          },
        },

        license: "cc-by-4",
        additionalLicenses: [
          {
            licenseName: "Apache License 2.0",
            licenseURI: "https://www.apache.org/licenses/LICENSE-2.0",
          },
        ],
        citationLabel: "OSLC-CCM-30-Primer",
        maxTocLevel: 3,
        conformanceLabelPrefix: "QM",
        // noConformanceStyling: 1,
        // noConformanceTable: 1,
        // conformanceClauseStrength : 1,
        editors: [],

        // name of the OP
        wg: "OASIS Open Services for Lifecycle Collaboration (OSLC) OP",
        wgShortName: "oslc-op",
        chairs: [
          {
            name: "Jim Amsden",
            mailto: "jamsden@us.ibm.com",
            company: "IBM",
            companyURL: "https://www.ibm.com/",
          },
          {
            name: "Andrii Berezovskyi",
            mailto: "andriib@kth.se",
            company: "KTH",
            companyURL: "https://www.kth.se/en",
          },
        ],
        editors: [
          {
            name: "David Honey",
            mailto: "DavidHoney@uk.ibm.com",
            company: "IBM",
            companyURL: "https://www.ibm.com/",
          },
        ],
      };
    </script>
    <style>
      table,
      th,
      td {
        border: 1px solid #666;
        border-collapse: collapse;
      }
      table th,
      table td {
        padding: 5px; /* Apply cell padding */
      }

      hr {
        border: none;
        border-top: 1px double #666;
        color: #666;
        overflow: visible;
        height: 0px;
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>This primer serves as a guide to the concepts in the TRS specification, and through the use of simple examples, explains how a data provider might expose resources in a TRS and how a TRS client might consume a data provider’s TRS.</p>
    </section>

    <section id="toc"></section>
    <section id="sotd"></section>

    <p>TRS 3.0 Primer is an OSLC OP Project Note</p>
    <section id="outline" class="level1">
    <h1>Outline</h1>
    <p>An OSLC Tracked Resource Set (TRS) provides a mechanism for making a set of resources discoverable and for reporting ongoing changes affecting the set. This allows tools to expose a live feed of linked lifecycle data in a way that permits other tools to build, aggregate, and maintain live, searchable information based on that linked data.</p>
    <p>TRS Clients can use Tracked Resource Sets to monitor or replicate some of the server’s resources, keeping up to date with changes. A single TRS Client could get information from many different Tracked Resource Sets. For example, a client might get information about requirements from a requirement management TRS, and test cases from a test management TRS, and provide query and reporting capabilities to show traceability between requirements and test cases.</p>
    <p>This primer serves as a guide to the concepts in the TRS specification, and through the use of simple examples, explains how a data provider might expose resources in a TRS and how a TRS client might consume a data provider’s TRS. The specification remains the definitive source, and where this primer differs from the specification, the specification should be taken as the authoritative reference.</p>
    </section>
    <section id="concepts" class="level1">
    <h1>Concepts</h1>
    <p>A <em>Tracked Resource Set</em> (TRS) is a resource that describes the set of <em>Tracked Resources</em> in the TRS. These are defined by a <em>Base</em> set of resources plus <em>Change Log</em> that is a set of ordered TRS <em>Events</em> that apply incrementally relative to the <em>Base</em>. The <em>Base</em> represents the set of tracked resources at some specific point in time. The ordering of TRS events after the base is specified by a <code>trs:order</code> property in each event. Each TRS event has a type which is one of the following:</p>
    <ol type="1">
    <li><code>trs:Creation</code> signifies that a tracked resource is created.</li>
    <li><code>trs:Modification</code> signifies that a tracked resource is modified.</li>
    <li><code>trs:Deletion</code> signifies a tracked resource is deleted.</li>
    </ol>
    <p>Example:</p>
    <pre><code>Base:
        uri1
        uri2

    Change Log Events:
        trs:order=1, trs:Creation uri3
        trs:order=2, trs:Modification uri2
        trs:order=3, trs:Creation uri4
        trs:order=4, trs:Deletion uri1
        trs:order=5, trs:Deletion uri4</code></pre>
    <p>The base contains tracked resources <code>uri1</code> and <code>uri2</code>. After the point in time represented by the base, the change log describes the following <em>ordered</em> sequence of changes:</p>
    <ol type="1">
    <li>A new tracked resource <code>uri3</code> was created.</li>
    <li>Tracked resource <code>uri2</code> was modified.</li>
    <li>A new tracked resource <code>uri4</code> was created.</li>
    <li>Tracked resource <code>uri1</code> was deleted.</li>
    <li>Tracked resource <code>uri4</code> was deleted.</li>
    </ol>
    <p>This represents a TRS that currently contains <code>uri2</code> and <code>uri3</code>. The ordering of events is critical. For example, if the event for the creation of <code>uri4</code> had an order of 6, then the final result is that the TRS contains <code>uri4</code>, and this is different from the intended result.</p>
    <p>Over time, the change log will continue to accumulate TRS events and without some means to limit its size, would become unmanageable and burdensome for servers to persist, and for clients to consume. The TRS specification addresses this through truncating change logs and rebasing. See <a href="9-change-log-truncation-and-rebase">Change log truncation and rebase</a> for details. After a change log truncation and rebase, the earlier example might become:</p>
    <pre><code>Base:
        uri2
        uri3
        uri4

    Change Log Events:
        trs:order=5, trs:Deletion uri4</code></pre>
    </section>
    <section id="starting-with-an-empty-trs" class="level1">
    <h1>Starting with an empty TRS</h1>
    <p>A GET of the TRS URI might return:</p>
    <pre><code>:trs
        a trs:TrackedResourceSet ;
        trs:base :trsBase ;
        trs:changeLog [
            a trs:ChangeLog ;
        ] .</code></pre>
    <p>This references a TRS base at <code>:trsBase</code> and a in-line change log that has no events. A GET of the TRS base may return a <em>redirect</em> to the first page of the TRS base. Typically a TRS base is split into pages as described in <a href="#-handling-a-large-trs-base">Handling a large TRS base</a>. If a client receives such a redirect, it should perform a GET on the URI of the first TRS base page specified by that redirect. The response to the GET of the redirected URI might be:</p>
    <pre><code>:trsBase
        a    ldp:#DirectContainer ;
        trs:cutoffEvent () ;
        ldp:hasMemberRelation ldp:member ;
        ldp:membershipResource :trsBase .</code></pre>
    <p>That base resource is a <em>Linked Data Platform Container</em> with no members (there are no tracked resources in the base), and with no <em>cutoff event</em>. The <em>cutoff event</em> comes only becomes relevant once a TRS base has been updated to include events from a change log. See <a href="#-change-log-truncation-and-rebase">Change log truncation and rebase</a> for details.</p>
    <p>A client reading the TRS for the first time would:</p>
    <ol type="1">
    <li>GET the TRS and determine the URI of the TRS base.</li>
    <li>GET the TRS base and record the tracked resources in the TRS base. In this case, this is an empty set.</li>
    <li>Look at the change log in the TRS from step 1 and process the events there, starting with the highest <code>trs:order</code>. Since there are no events in the change log, there are no tracked resources in the change log.</li>
    </ol>
    <p>The result is the client sees a TRS with no member tracked resources.</p>
    </section>
    <section id="adding-trs-events" class="level1">
    <h1>Adding TRS events</h1>
    <p>Consider that our example data provider adds a tracked resource <code>:tracked1</code>. The change log should contain a <code>trs:Creation</code> event (or a <code>trs:Modification</code> event) for <code>:tracked1</code>. While a <code>trs:Creation</code> event more accurately describes the creation of a tracked resource, clients should treat an initial <code>trs:Modification</code> event equivalently to a creation event.</p>
    <p>A GET on <code>:trs</code> might return:</p>
    <pre><code>:trs
        a trs:TrackedResourceSet ;
        trs:base :trsBase ;
        trs:changeLog [
            a trs:ChangeLog ;
            trs:change &lt;urn:example:example.com:2021-02-05T17:39:33.000Z:1&gt; .
        ] .

    &lt;urn:example:example.com:2021-02-05T17:39:33.000Z:1&gt;
        a trs:Creation ;
        trs:changed :tracked1 ;
        trs:order &quot;1&quot;^^xsd:integer .</code></pre>
    <p>There are several things worthy of note:</p>
    <ol type="1">
    <li>The ordering of the events referenced in the change log is determined by the <code>trs:order</code> property of each of the referenced events. It’s required that events describing later changes must have unique and higher order values than earlier events. <code>trs:order</code> values are not required to be <em>consecutive</em>, so a client cannot use the order property to check for missing events.</li>
    <li>The RDF data type for <code>trs:order</code> should be <code>xsd:integer</code> (and not <code>xsd:int</code>) because, over time, new order values could become arbitrarily large and beyond the range of, for example, a 32-bit integer.</li>
    <li>The URI of an event in the change log should be stable over time and be guaranteed to be unique. For example, if a TRS gets truncated and/or rebased, existing events in the change log should retain the same URI. It should never be the case that a new event reuses a URI that was used even if the server is restored from a backup. The URI of an event should therefore not be solely based on its <code>trs:order</code> value. See <a href="#-making-clients-tolerant-of-server-restore-from-backup">Making clients tolerant of server restore from backup</a> for further details.</li>
    </ol>
    <p>The TRS base was not changed by this operation.</p>
    <p>A client that had earlier read the empty TRS would now:</p>
    <ol type="1">
    <li>GET the TRS.</li>
    <li>Look at the change log and process the events there, starting with the highest <code>trs:order</code> continuing until the last previously-processed event (in this case none) was encountered. It records the creation of <code>:tracked1</code>.</li>
    <li>Record the URI of the most recently processed event. In this example, that is <code>urn:example:example.com:2021-02-05T17:39:33.000Z:1</code>.</li>
    </ol>
    <p>The client should therefore see the TRS as having members <code>:tracked1</code>.</p>
    <p>Now consider that our example data provider adds a tracked resource <code>:tracked2</code>.</p>
    <p>A GET on <code>:trs</code> might return:</p>
    <pre><code>:trs
        a trs:TrackedResourceSet ;
        trs:base :trsBase ;
        trs:changeLog [
            a trs:ChangeLog ;
            trs:change &lt;urn:example:example.com:2021-02-05T17:39:33.000Z:1&gt; ;
            trs:change &lt;urn:example:example.com:2021-02-05T17:40:12.000Z:2&gt; .
        ] .

    &lt;urn:example:example.com:2021-02-05T17:39:33.000Z:1&gt;
        a trs:Creation ;
        trs:changed :tracked1 ;
        trs:order &quot;1&quot;^^xsd:integer .

    &lt;urn:example:example.com:2021-02-05T17:40:12.000Z:2&gt;
        a trs:Creation ;
        trs:changed :tracked2 ;
        trs:order &quot;2&quot;^^xsd:integer .</code></pre>
    <p>The client that previously read the TRS would:</p>
    <ol type="1">
    <li>GET the TRS.</li>
    <li>Look at the change log process the events there, starting with the highest <code>trs:order</code> continuing until the last previously-processed event (in this case <code>urn:example:example.com:2021-02-05T17:39:33.000Z:1</code>) was encountered. It records the creation of <code>:tracked2</code>.</li>
    <li>Record the URI of the most recently processed event. In this example, that is <code>urn:example:example.com:2021-02-05T17:40:12.000Z:2</code>.</li>
    </ol>
    <p>The client should therefore see the TRS as having members <code>:tracked1</code> and <code>:tracked2</code>.</p>
    </section>
    <section id="handling-large-number-of-events-in-a-change-log" class="level1">
    <h1>Handling large number of events in a change log</h1>
    <p>Servers should be able to handle a large number of TRS events. Returning all the events in the in-line change log of the TRS resource would not be practical or scaleable. TRS clients should not be expected to handle arbitrarily large responses to a GET of a TRS. The TRS specification describes a mechanism for segmentation of a change log. The change log embedded in the response to a GET of the TRS includes a limited number of the most recent events, and then includes a <code>trs:previous</code> referencing a URI that will return the next <em>segment</em> of the change log. A GET of that page would also return a change log referencing the next set of older events , and a <code>trs:previous</code> referencing a URI that will return the next segment. A client can thus perform a GET of each segment, and process a response whose size is constrained by some implementation-defined limit on the number of events per segment.</p>
    <p>Let’s imagine that our example data provider adds another tracked resource <code>:tracked3</code>. A GET of the TRS might respond with:</p>
    <pre><code>:trs
        a trs:TrackedResourceSet ;
        trs:base :trsBase ;
        trs:changeLog [
            a trs:ChangeLog ;
            trs:change &lt;urn:example:example.com:2021-02-05T17:40:12.000Z:2&gt; ;
            trs:change &lt;urn:example:example.com:2021-02-05T17:42:55.000Z:3&gt;
            trs:previous &lt;trsChangeLog?before=2&gt;
        ] .

    &lt;urn:example:example.com:2021-02-05T17:40:12.000Z:2&gt;
        a trs:Creation ;
        trs:changed :tracked2 ;
        trs:order &quot;2&quot;^^xsd:integer .

    &lt;urn:example:example.com:2021-02-05T17:42:55.000Z:3&gt;
        a trs:Creation ;
        trs:changed :tracked3 ;
        trs:order &quot;3&quot;^^xsd:integer .</code></pre>
    <p>In this case, the embedded change log only includes the most recent 2 events (<code>trs:order</code> values 2 and 3). If a client needs to examine older events, it should perform a GET on the previous segment <code>trsChangeLog?before=2</code> which might provide:</p>
    <pre><code>&lt;trsChangeLog?before=2&gt;
        a trs:ChangeLog
        trs:change &lt;urn:example:example.com:2021-02-05T17:39:33.000Z:1&gt; .

    &lt;urn:example:example.com:2021-02-05T17:39:33.000Z:1&gt;
        a trs:Creation ;
        trs:changed :tracked1 ;
        trs:order &quot;1&quot;^^xsd:integer .</code></pre>
    <p>In this way a client can iterate over the change log, getting previous segments until it encounters a change event it has already processed or there are no more segments to process. Change log segments are ordered from the most recent change in the first page, going back in time with each page, with the oldest change in the last page. A change log page must not contain order numbers higher than any in the more recent pages already encountered - that is, each page of events must be strictly older than all previously read pages.</p>
    <p>What maximum number of events should be served in the in-lined change log, and in each subsequent segment?</p>
    <p>If the maximum number of events per segment is too small, clients will have to make many more GET requests to process events, and if network latency is significant, this could be slower than using larger segments. Typically, TRS clients will poll a TRS server on a regular basis. If the maximum number of events in the first segment is too large, a client will get a TRS with a large embedded change log, of which only the most recent events in the last poll interval will be processed. Ideally, for the first segment, the maximum number of events should be larger than the average number of new events per poll interval, but not so large that the response is too large for a client to process. Subsequent segments might be larger, and tend only to be read by TRS clients processing the TRS for the first time. An implementation should probably have a configurable property for each of the initial change log size and the subsequent segment size. A default value of 1000 events might be an appropriate starting point for both properties. They can be reviewed and adjusted based on event rate per poll interval and the total number of TRS events.</p>
    <p>It is required that segmentation of the change log is <em>stable</em>. That is, a client that starts processing the change log embedded in the TRS and processes each <code>trs:previous</code> segment should not miss any tracked resources between those segments, even if new events are added to the TRS.</p>
    <p>One implementation approach for servers is to persist each TRS event as a row in a table of events. This allows servers to handle a very large number of events. A GET on the TRS can get the first segment of events by querying for the most recent <em>N</em> events and include those in the change log embedded in the RDF of the TRS. The <code>trs:previous</code> can use a URI that includes a query parameter that references the oldest <code>trs:order</code> that was included. A GET on that URI can then query for the next <em>M</em> events whose <code>trs:order</code> is greater than that value. Such queries tend to scale well, and provide the stable segmentation required by clients.</p>
    </section>
    <section id="ensuring-events-are-exposed-with-increasing-trsorder-values" class="level1">
    <h1>Ensuring events are exposed with increasing <code>trs:order</code> values</h1>
    <p>The TRS specification requires that TRS events are exposed with increasing <code>trs:order</code> values. Consider a non-compliant TRS server that exposes a change log over time as follows:</p>
    <pre><code>Time 10.0 seconds
        &lt;event100Uri&gt; trs:order=100
        &lt;event101Uri&gt; trs:order=101

    Time 15.0 seconds
        &lt;event100Uri&gt; trs:order=100
        &lt;event101Uri&gt; trs:order=101
        &lt;event103Uri&gt; trs:order=103

    Time 20.0 seconds
        &lt;event100Uri&gt; trs:order=100
        &lt;event101Uri&gt; trs:order=101
        &lt;event102Uri&gt; trs:order=102
        &lt;event103Uri&gt; trs:order=103</code></pre>
    <p>A TRS client might consume this over time as follows:</p>
    <ol type="1">
    <li>At time 11.0 seconds, GET the TRS and embedded change log. Consume events with orders 100, and 101. Record the <em>sync point</em> as <code>event101Uri</code>.</li>
    <li>At time 16.0 seconds, GET the TRS and embedded change log. Consume events after last processed event <code>event101Uri</code>, which consists of one event with order 103. Record the <em>sync point</em> as <code>event103Uri</code>.</li>
    <li>At time 21.0 seconds, GET the TRS and embedded change log. Consume events after last processed event <code>event103Uri</code>, of which there are none.</li>
    </ol>
    <p>This could result in a client missing processing the event with <code>trs:order=102</code> because that event was exposed in the change log <strong>after</strong> the event with <code>trs:order=103</code> was exposed. This is why the specification requires that events must be <em>exposed with increasing <code>trs:order</code></em>.</p>
    <p>Achieving this requirement is sometimes not straightforward. A server persisting its tracked resources in a relational database may want to use a single atomic transaction to save a resource’s changes to the database and to create a TRS event describing those changes. Consider what might happen if the <code>trs:order</code> value is allocated within that transaction, either explicitly in code, or being automatically allocated using an auto-incrementing sequence provided by the relational database. If there are two such operations <code>O1</code> and <code>O2</code> running concurrently, even if the allocation occurs in the order <code>O1</code> followed by <code>O2</code>, there is no guarantee that the <em>commits</em> of those transactions will complete in that order. There is a risk that <code>O2</code> might complete commit before <code>O1</code>. Many implementations, may use <em>read committed</em> mode, which means that data changed in a transaction only becomes visible outside of that transaction once it has been successfully committed. So there is a real risk that the TRS event for <code>O2</code> with a higher <code>trs:order</code> might be exposed <strong>before</strong> the TRS event for <code>O1</code> with a lower <code>trs:order</code>.</p>
    <p>One approach is to create <em>private</em> TRS events within transactions, and then have separate processing after transaction commit that is single-threaded that allocates the <code>trs:order</code> value and makes the event <em>public</em>.</p>
    <p>It is also recommended that for resilience against TRS servers that do not address this issue, TRS clients be tolerant of such TRS server defects. A more tolerant client might record the last <em>N</em> ordered URIs of processed events as the <em>sync point</em>, and be tolerant of incorrect ordering within a window of <em>N</em> events. In our example, for <em>N</em>=2 the sequence might be:</p>
    <ol type="1">
    <li>At time 11.0 seconds, GET the TRS and embedded change log. Consume events with orders 100, and 101. Record the <em>sync point</em> as [<code>event100Uri</code>, <code>event101Uri</code>].</li>
    <li>At time 16.0 seconds, GET the TRS and embedded change log. Check for any events in between the <code>trs:order</code> for <code>event100Uri</code> and <code>event101Uri</code>. There are none. so process the next event after <code>event101Uri</code>, which is <code>event103Uri</code>. Record the <em>sync point</em> as [<code>event101Uri</code>, <code>event103Uri</code>].</li>
    <li>At time 21.0 seconds, GET the TRS and embedded change log. Check for any events in between the <code>trs:order</code> for <code>event101Uri</code> and <code>event103Uri</code>. There is one missed event <code>event102Uri</code>. Process events starting with this missed event and then move forwards to process events with higher <code>trs:order</code> values.</li>
    </ol>
    <p>Note that if missing earlier events are detected due to incorrect order of publication, and those events are <code>trs:Modification</code> events with patches (see <a href="5-patch-events">Patch events</a>), a client should ignore the patch and fetch the complete resource.</p>
    <p>In this way, the TRS client would be tolerant of small time windows in which the <code>trs:order</code> values might not be exposed in increasing order.</p>
    </section>
    <section id="patch-events" class="level1">
    <h1>Patch events</h1>
    <p>Consider a tracked resource whose RDF content is very large, and when modified, the changes to that RDF content represent a small fraction of the overall content. If a TRS server generates a standard <code>trs:Modification</code> event, then a client has to fetch the entire content of the changed tracked resource. The TRS specification defines a <em>patch</em> mechanism so that a modification event can include the delta of RDF changes from the current state defined by the event and a previous event, which might be another patch, a regular <code>trs:Modification</code> or <code>trs:Creation</code> event, or an entry in a TRS base page. This reduces the burden on a TRS client in maintaining the content of the tracked resource.</p>
    <p>Consider a tracked resource that is a container referencing other resources whose current etag is <code>15687ds9gha6s7</code>:</p>
    <pre><code>@prefix dcterms: &lt;http://purl.org/dc/terms/&gt;.
    @prefix ldp: &lt;http://www.w3.org/ns/ldp#&gt;.
    &lt;https://a.example.com/container/a1&gt;
       a ldp:BasicContainer;
       dcterms:title &quot;Container A1&quot;;
       ldp:member &lt;https://a.example.com/version/s/143&gt;;
       ldp:member &lt;https://a.example.com/version/r/577&gt;;
       ldp:member &lt;https://a.example.com/version/t/033&gt;.</code></pre>
    <p>The container is updated, replacing member <code>https://a.example.com/version/r/577</code> with member <code>https://a.example.com/version/r/578</code> giving a resource with etag <code>285d4h2ffgddd9</code> and the following RDF content:</p>
    <pre><code>@prefix dcterms: &lt;http://purl.org/dc/terms/&gt;.
    @prefix ldp: &lt;http://www.w3.org/ns/ldp#&gt;.
    &lt;https://a.example.com/container/a1&gt;
       a ldp:BasicContainer;
       dcterms:title &quot;Container A1&quot;;
       ldp:member &lt;https://a.example.com/version/s/143&gt;;
       ldp:member &lt;https://a.example.com/version/r/578&gt;;
       ldp:member &lt;https://a.example.com/version/t/033&gt;.</code></pre>
    <p>A TRS server might create a <code>trs:Modification</code> event describing this change as follows:</p>
    <pre><code>@prefix trs: &lt;http://open-services.net/ns/core/trs#&gt;.
    @prefix trspatch: &lt;http://open-services.net/ns/core/trspatch#&gt;.
    &lt;urn:example:6e8bc430:a.example.com:2014-04-28T17:39:32.000Z:102&gt;
       a trs:Modification;
       trs:changed &lt;https://a.example.com/container/a1&gt;;
       trs:order &quot;102&quot;^^xsd:integer;
       trspatch:beforeEtag &quot;15687ds9gha6s7&quot;;
       trspatch:afterEtag &quot;285d4h2ffgddd9&quot;;
       trspatch:rdfPatch
         &quot;&quot;&quot;
          D &lt;https://a.example.com/container/a1&gt; &lt;http://www.w3.org/ns/ldp#member&gt; &lt;https://a.example.com/version/r/577&gt; .
          A &lt;https://a.example.com/container/a1&gt; &lt;http://www.w3.org/ns/ldp#member&gt; &lt;https://a.example.com/version/r/578&gt; .
         &quot;&quot;&quot;.</code></pre>
    <p>The event contains a <code>trspatch:rdfPatch</code> that specifies:</p>
    <ol type="1">
    <li>The triple <code>&lt;https://a.example.com/container/a1&gt; &lt;http://www.w3.org/ns/ldp#member&gt; &lt;https://a.example.com/version/r/577&gt;</code> is deleted.</li>
    <li>The triple <code>&lt;https://a.example.com/container/a1&gt; &lt;http://www.w3.org/ns/ldp#member&gt; &lt;https://a.example.com/version/r/578&gt;</code> is added.</li>
    </ol>
    <p>A TRS patch has to specify the triples (RDF statements) that are to be deleted and/or added. The use of RDF blank nodes in patches is problematic since they are not guaranteed to be stable over time. Hence TRS patches should not be used to represent deltas where the changes involve blank nodes.</p>
    <p>Patch events may also reference a <code>trspatch:createdFrom</code> as a means of representing a new resource whose RDF is formed from another <em>created from</em> resource plus the patch delta. Consider the case where version 2 of some artifact is created from version 1. Version 2 might inherit a significant set of common RDF data from version 1. An application might represent the TRS event for version 2 as a patch specifying a <code>trspatch:createdFrom</code> referencing version 1 and the RDF delta between version 2 and version 1.</p>
    <p>When there is a chain of patch events, the <code>beforeEtag</code> of a patch must match the <code>afterEtag</code> of the immediately preceding patch. For patch events to work reliably, it’s important that the patch events are complete, and ordered correctly, and that TRS clients can validate this. This becomes increasingly important as the chain of patch events grows in size. If a TRS client detects that the <code>beforeEtag</code> of a patch does not match the <code>afterEtag</code> of an immediately preceding patch, it should assume the patch is untrustworthy and fetch the complete the resource, in effect, treating the <code>trs:Modification</code> event as if the patch were absent.</p>
    <p>For TRS servers, the implementation should consider limiting the length of patch chains. For example, a TRS server might emit a normal <code>trs:Modification</code> event after <em>N</em> patch events for that tracked resource in order trigger a full fetch of the tracked resource periodically by clients.</p>
    </section>
    <section id="handling-a-large-trs-base" class="level1">
    <h1>Handling a large TRS base</h1>
    <p>Just as with the change log, it’s not practical for a GET on the TRS base to return all the members of the base where the number of members is large. Typically, TRS servers implement a <em>paged base</em> where a GET on the TRS base returns a redirect to the first base page. Where there are additional pages, the response to the GET of a base page must include an LDP <code>Link</code> header of the form <code>Link: &lt;</code><em>nextPageUri</em><code># &gt;; rel="next"</code>.</p>
    <p>For example, the first GET of the TRS base <code>:trsBase</code> might return a redirect to the first base page at <code>&lt;trsBase/1&gt;</code>, and a GET from <code>&lt;trsBase/1&gt;</code> might return:</p>
    <pre><code>:trsBase
        a    ldp:#DirectContainer ;
        trs:cutoffEvent () ;
        ldp:hasMemberRelation ldp:member ;
        ldp:membershipResource :trsBase ;
        ldp:member &lt;uri1&gt; , &lt;uri2&gt; , ... &lt;uri1000&gt; .</code></pre>
    <p>The response might contain the header <code>Link: &lt;trsBase/2&gt;; rel="next"</code>. A GET of the next page at <code>&lt;trsBase/2&gt;</code> might return:</p>
    <pre><code>:trsBase
        a    ldp:#DirectContainer ;
        ldp:hasMemberRelation ldp:member ;
        ldp:membershipResource :trsBase ;
        ldp:member &lt;uri1001&gt; , &lt;uri1002&gt; , ... &lt;uri2000&gt; .</code></pre>
    <p>The response might contain the header <code>Link: &lt;trsBase/3&gt;; rel="next"</code>. Note that the 2nd and subsequent pages do not need to include the <code>trs:cutoffEvent</code> property.</p>
    <p>It’s important that the paging of the TRS base is <em>stable</em>. A client should be able to iterate over all the base pages and be guaranteed to see all the entries up until the moment that the last page is returned. This means that new entries to the base should only be added to the last page, creating a new page as required. Base page members should only be removed during change log truncation and rebase.</p>
    <p>How many members should be included in each TRS base page?</p>
    <p>If each base page is small, a TRS client that needs to process the base will have to perform many more GETs, and with significant network latency, this could adversely affect performance. Conversely, a base page that is too large could take too long to construct and return, resulting in socket timeouts, or result in a response that is too large for a client to handle. Ideally the base page size should be configurable. A suggested starting point is 1000 members per base page.</p>
    <p>There are several implementation designs that a TRS server might consider:</p>
    <ol type="1">
    <li>Persist TRS base pages explicitly. Each base page is a persisted entity, and references the members of that page.</li>
    <li>Persist base members as separate rows in a table and perform paging of the base at run time. In order to achieve stable paging, each member will need to be ordered, and a <code>trs:order</code> value or a member creation time might provide an appropriate sort order.</li>
    </ol>
    <p>Option 1 is likely to be a more compact representation, and it makes it very easy to serve any base page via a REST service. However, when base members are removed during change log truncation, this is likely to lead to only partially populated, or possibly even empty, base pages. This kind of base page fragmentation can be avoided with option 2. However, paging could become unstable during change log truncation. The deletion of a base member would shift the newer base members up in the query of members. So achieving stable paging may become more complex.</p>
    <p>TRS servers might consider providing a way to completely recompute the TRS, creating a new TRS base from scratch. It’s important that while such a base reconstruction in progress, the existing base and change log remain viable. A server might achieve this by constructing the new base as private data, temporarily suspending any updates to the active base, and then deleting the old base and exposing the new base in a single atomic transaction. However, there is danger that the new base might include members that were absent from the old base, or have members that are absent that were present in the old base. A TRS client that is running incrementally would not know that the base needed to be reprocessed. One way of avoiding this is for the recompute of the TRS to also clear the TRS change log and use a base <code>cutoffEvent</code> of <code>rdf:nil</code>. A client should detect the <em>sync point URI</em> does not exist in the change log and reprocess the entire TRS.</p>
    </section>
    <section id="how-should-trs-clients-consume-a-trs" class="level1">
    <h1>How should TRS clients consume a TRS</h1>
    <p>TRS clients should maintain a <em>sync point URI</em> that records the URI of the latest change event that has been processed. This will be required for incremental consumption.</p>
    <section id="initial-consumption-of-a-trs" class="level2">
    <h2>Initial consumption of a TRS</h2>
    <ol type="1">
    <li>GET the TRS to retrieve the URI of the TRS base.</li>
    <li>GET successive pages of the base, processing each member resource as required.</li>
    <li>Invoke the procedure described in <a href="#-incremental-update-procedure">Incremental Update Procedure</a> with the <em>sync point URI</em> set to the <code>trs:cutoffEvent</code> property on the first page of the based (which could be <code>rdf:nil</code>).</li>
    </ol>
    </section>
    <section id="incremental-consumption-of-a-trs" class="level2">
    <h2>Incremental consumption of a TRS</h2>
    <ol type="1">
    <li>Invoke the the procedure described in <a href="#-incremental-update-procedure">Incremental Update Procedure</a> with the <em>sync point URI</em> set to the URI of the most recent previously processed change event.</li>
    </ol>
    <section id="incremental-update-procedure" class="level3">
    <h3>Incremental update procedure</h3>
    <ol type="1">
    <li>GET the TRS resource to get the first segment of the change log.</li>
    <li>Process events from the newest (highest <code>trs:order</code>) to oldest.</li>
    <li>For <code>trs:Creation</code> events and <code>trs:Modification</code> events without a <em>patch</em>, process the tracked resource. Typically a client will fetch the complete RDF of that tracked resource. Record that tracked resource as processed. If an older event for that tracked resource is encountered, ignore it.</li>
    <li>For a `<code>trs:Modification</code> event with a <em>patch</em>, record the event for later <em>patch processing</em>. This is required because patch events have to be processed in the order oldest to newest.</li>
    <li>For a <code>trs:Deletion</code> event, process the tracked resource. A client might remove any persisted content for that resource. Record that tracked resource was processed. If an older event for that tracked resource is encountered, ignore it.</li>
    <li>If the event at the <em>sync point URI</em> is encountered, the first pass of processing terminates and proceeds to <em>patch processing</em>. If the end of the current change log segment is reached, then fetch any next segment and continue processing as above.</li>
    </ol>
    <p>At this stage, all of the non-patch events have been processed. If there are any modification events with patches to be processed, for each tracked resource, process the patches ordered from the oldest to the newest. A client might take the RDF of the tracked resource was it was last updated and persisted, and then apply the deletions and additions of each patch. Clients should check the <code>beforeEtag</code> of a patch matches the <code>afterEtag</code> of any prior patch. If these do not match, a client should fetch the entire tracked resource.</p>
    </section>
    </section>
    </section>
    <section id="making-clients-tolerant-of-server-restore-from-backup" class="level1">
    <h1>Making clients tolerant of server restore from backup</h1>
    <p>Consider a TRS whose change log contains events for <code>trs:order</code> values 1 to 1000. A TRS client might read that TRS and record the last processed event URI as <code>&lt;event1000Uri&gt;</code>. On the next poll, the TRS client will be looking for events with a <code>trs:order</code> greater than the event <code>&lt;event1000Uri&gt;</code>. If the TRS server was restored from a previous day’s backup, the restored TRS might only have TRS events for <code>trs:order</code> values 1 to 900. If a TRS clients polls that TRS at that time, it should detect that event <code>&lt;event1000Uri&gt;</code> does not exist, and reprocess the entire TRS.</p>
    <p>However, consider the case where the server created an additional 200 events after restore from backup but before the next poll by a TRS client. If that results in <code>&lt;event1000Uri&gt;</code> being used for one of those new events, the clients incremental TRS update procedure is likely to miss processing events. This is why TRS servers should guarantee unique event URIs, even if the <code>trs:order</code> value is reused after restore from backup. A TRS event URI must not rely on the <code>trs:order</code> alone to achieve uniqueness. Servers might consider using a GUID persisted as data on events, or embedding a date time string with the <code>trs:order</code> in the URI.</p>
    </section>
    <section id="change-log-truncation-and-rebase" class="level1">
    <h1>Change log truncation and rebase</h1>
    <p>TRS servers should not allow a TRS change log to grow without limit. A server should provide a means to <em>truncate</em> the change log in a well-behaved manner so that TRS base is updated to reflect new members, and deleted old members are removed from the base. A server might implement an automatic periodic truncation and base update, and/or provide a capability for an administrator to initiate this manually.</p>
    <p>Consider a TRS with an empty base, and a change log with 5 TRS events. A GET on the TRS might return:</p>
    <pre><code>:trs
        a trs:TrackedResourceSet ;
        trs:base :trsBase ;
        trs:changeLog [
            a trs:ChangeLog ;
            trs:change &lt;urn:example:example.com:2021-02-05T17:39:33.000Z:1&gt; ;
            trs:change &lt;urn:example:example.com:2021-02-05T17:40:12.000Z:2&gt; ;
            trs:change &lt;urn:example:example.com:2021-02-05T17:42:55.000Z:3&gt; ;
            trs:change &lt;urn:example:example.com:2021-02-06T11:09:11.000Z:4&gt; ;
            trs:change &lt;urn:example:example.com:2021-02-06T11:17:42.000Z:5&gt; .
        ] .

    &lt;urn:example:example.com:2021-02-05T17:39:33.000Z:1&gt;
        a trs:Creation ;
        trs:changed :tracked1 ;
        trs:order &quot;1&quot;^^xsd:integer .

    &lt;urn:example:example.com:2021-02-05T17:40:12.000Z:2&gt;
        a trs:Creation ;
        trs:changed :tracked2 ;
        trs:order &quot;2&quot;^^xsd:integer .

    &lt;urn:example:example.com:2021-02-05T17:42:55.000Z:3&gt;
        a trs:Deletion;
        trs:changed :tracked1 ;
        trs:order &quot;3&quot;^^xsd:integer .

    &lt;urn:example:example.com:2021-02-06T11:09:11.000Z:4&gt;
        a trs:Modification ;
        trs:changed :tracked2 ;
        trs:order &quot;4&quot;^^xsd:integer .

    &lt;urn:example:example.com:2021-02-06T11:17:42.000Z:5&gt;
        a trs:Creation ;
        trs:changed :tracked3 ;
        trs:order &quot;5&quot;^^xsd:integer .</code></pre>
    <p>The TRS base is empty, so a GET might return:</p>
    <pre><code>:trsBase
        a    ldp:#DirectContainer ;
        trs:cutoffEvent () ;
        ldp:hasMemberRelation ldp:member ;
        ldp:membershipResource :trsBase .</code></pre>
    <p>When events from the change log are processed to update the base, the TRS base must have a <em>cutoff event</em> that references the URI of the event in the change log that was most recently processed for the TRS base. This event referenced by the cutoff should not be processed as part of the change log processing as part of the <a href="71-initial-consumption-of-a-trs">Initial consumption of a TRS</a>.</p>
    <p>A TRS server may later remove some of the events that were processed for the base and that are older than the base cutoff. The change log must never be truncated to the extent that the cutoff event itself disappears from the change log.</p>
    <p>So if a TRS server fully processed the events, updated the base, and truncated the change log, the resultant TRS would be as follows:</p>
    <pre><code>:trs
        a trs:TrackedResourceSet ;
        trs:base :trsBase ;
        trs:changeLog [
            a trs:ChangeLog ;
            trs:change &lt;urn:example:example.com:2021-02-06T11:17:42.000Z:5&gt; .
        ] .

    &lt;urn:example:example.com:2021-02-06T11:17:42.000Z:5&gt;
        a trs:Creation ;
        trs:changed :tracked3 ;
        trs:order &quot;5&quot;^^xsd:integer .</code></pre>
    <p>and the TRS base would be:</p>
    <pre><code>:trsBase
        a    ldp:#DirectContainer ;
        trs:cutoffEvent &lt;urn:example:example.com:2021-02-06T11:17:42.000Z:5&gt; ;
        ldp:hasMemberRelation ldp:member ;
        ldp:membershipResource :trsBase ;
        ldp:member :tracked2, :tracked3 .</code></pre>
    <p>Note that the <code>trs:cutoffEvent</code> references the URI of the the event in the change log that was last processed for the base. Tracked resource <code>:tracked1</code> is not in the TRS base because the most recent event for it in the change log prior to truncation was a <code>trs:Deletion</code>.</p>
    <p>In practice, TRS servers should <strong>not</strong> perform such a brutal truncation and rebase. A TRS client may not have processed all the events that were in the change log prior to truncation. In order to provide adequate response to client requests, a TRS server needs to allow those clients sufficient time to read the base, the change log, and process the set of tracked resources. However, the data volumes and timescales involved in TRS processing are likely to vary between servers for different applications. A server representing Amazon transactions might have many events per second, while a server representing exhibits at a museum might have a few events per month. The cost of processing a single event is also likely to vary between applications; reading a new or modified resource with 5 RDF properties will take less time than reading one with 5,000 properties.</p>
    <p>For these reasons, the TRS specification does not impose specific constraints over the length of time for which a TRS base must remain readable, nor what the degree of overlap should be between a base and a corresponding change log. A server implementing TRS must consider, and should document, the quality of service it will provide in terms of the size of pages in the base or change log, how long base pages are kept, how long change events are kept, and the minimum period for which change events behind the latest base cutoff are kept.</p>
    <p>Related to this is the issue of deletions in a TRS base arising from change log truncation. Consider a TRS client reading a TRS for the first time while a <code>trs:Deletion</code> event is being truncated from the change log and the corresponding member is being removed from a base page. A client may have processed the base page before that member was removed, but if, some considerable time later, the event was removed from the change log, the client would not see the deletion. The result would be a client that erroneously records that tracked resource as being in the TRS. To avoid this, it is recommended that truncation and base update is processed in two phases:</p>
    <ol type="1">
    <li>Events older than <em>N</em> days, are processed so that the resources are added or removed from base pages are required. The cutoff event of the base is updated to the URI of the most recent event that was processed for the base. However, those events are <strong>not</strong> deleted from the change log at this time.</li>
    <li>Events that were processed for base page updates in step 1, are deleted from the change log at least <em>M</em> days after they were processed in step 1.</li>
    </ol>
    <p>It is recommended that <em>N</em> and <em>M</em> are configurable properties, and that a server documents the default values of these properties. Suitable default values depend on the frequency of events and how often TRS clients poll the TRS. A suggested starting point is for <em>N</em>=7 days and for <em>M</em>=14 days. This would keep events in the change log for at least 21 days. Providing that a TRS client can process the base pages and change log in less than 21 days, it will not miss deletions of tracked resources.</p>
    </section>
    <section id="general-guidance-for-trs-servers" class="level1">
    <h1>General guidance for TRS servers</h1>
    <ul>
    <li><p>A TRS server should restrict itself to a small number of TRSs.</p></li>
    <li><p>If a TRS server provides multiple TRSs, any single tracked resource should be a member of only one of those TRSs. In other words, each TRS should be a disjoint set of tracked resources. For example, a requirements management application might publish a TRS for requirements resources, and a separate TRS for tracked resources representing users and user groups.</p></li>
    <li><p>The members of a TRS should be tracked resources that are control of the server. In the case of a TRS adapter for an existing application, the TRS adapter should only expose that application’s resources. In other words, the subjects of a lifecycle tool claims should be its own resources, as opposed to resources of some other lifecycle tool.</p></li>
    </ul>
    <p><em>Nick: this is a Jim de Rivieres comment with which many of us do not agree. There are valid reasons for a TRS feed for ‘foreign’ resources, perhaps for some kind of adapter.</em></p>
    <ul>
    <li><p>A TRS should expose regular linked lifecycle data resources, and associated resources such as resource shapes, including properties and their referenced allowed values. This allows a TRS client to determine a <em>type system model</em> for the data that might be useful for constructing and executing reports.</p></li>
    <li><p>A TRS server should report operations on tracked resources as new TRS events within a short time of the changes being persisted in the server. This allows TRS clients to obtain a live feed of changes in nearly real-time. If a server takes longer than a second or two to publish TRS events, the server should document the quality of service it supports so that clients understand the latency in getting events for changes.</p></li>
    <li><p>A TRS server should maintain a change log of events for a certain duration, and this should be configurable. A server should document the default duration. This allows a TRS client to be offline for less than that duration and then resume processing of the TRS without missing events.</p></li>
    <li><p>A TRS server should provide some means of truncating the change log to limit the number of TRS events a new TRS client has to process.</p></li>
    <li><p>TRS servers should create a TRS event for a tracked resource in the same atomic transaction in which the tracked resource itself is created, modified, or deleted.</p></li>
    <li><p>TRS servers should use URIs for events that are unique and will not be reused for later events, even if the server is restored from backup.</p></li>
    <li><p>TRS servers should limit the maximum size of patches in <code>trs:Modification</code> events.</p></li>
    <li><p>TRS servers should consider limiting the length of patch event chains, and consider periodically using a <code>trs:Modification</code> event without a patch to require that a client fetch the complete resource. This helps to improve the robustness of the TRS for clients.</p></li>
    </ul>
    </section>
    <section id="general-guidance-for-trs-clients" class="level1">
    <h1>General guidance for TRS clients</h1>
    <ul>
    <li><p>Clients should read the base and change log as quickly as they can, and not delay for extended periods of time between reading the base and the change log, or between reading pages of the base.</p></li>
    <li><p>Clients are expected to repeat the incremental update procedure on a regular basis to keep up with changes, perhaps as often as every minute, and at least often enough so that events are not lost by change log truncation. The poll interval should be configurable, and clients should document the default.</p></li>
    <li><p>Clients should be defensive against imperfect or untrustworthy TRS servers. A client that is persisting data about tracked resources should place limits on the number of tracked resources, and the data representation size of each tracked resource. For example, if a data provider exposes a tracked resource whose RDF content includes a very large RDF literal, a client should limit the impact of data, either truncating the literal in some fashion, or discarding that data.</p></li>
    <li><p>Clients that encounter error conditions in a TRS should report those errors in an appropriate way that allows such errors to be made visible, and for the TRS server development team to investigate the issue.</p></li>
    <li><p>Clients should treat <code>trs:Creation</code> events in the same way as <code>trs:Modification</code> events.</p></li>
    <li><p>Clients should consider fetching tracked resources concurrently to improve performance.</p></li>
    </ul>
    </section>
  </body>
</html>
